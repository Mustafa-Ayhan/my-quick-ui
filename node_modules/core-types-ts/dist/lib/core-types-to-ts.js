import ts from 'typescript';
import { isPrimitiveType, UnsupportedError, } from 'core-types';
import { createCodeHeader, generateCode, safeName, tsUnknownTypeAnnotation, wrapAnnotations, } from './ts-helpers.js';
const { factory } = ts;
const createdByPackage = 'core-types-ts';
const createdByUrl = 'https://github.com/grantila/core-types-ts';
function throwUnsupported(msg, node, meta) {
    throw new UnsupportedError(msg, { loc: node.loc, ...meta });
}
export function convertCoreTypesToTypeScript(doc, opts = {}) {
    const { version, types } = doc;
    if (version !== 1)
        throw new UnsupportedError(`core-types version ${version} not supported`);
    const convertedTypes = [];
    const wrapInNamespaces = (code, namespaceList) => namespaceList.length === 0
        ? code
        : namespaceList.map(ns => `namespace ${ns} {`).join(' ') +
            `\n${code}\n` +
            namespaceList.map(() => '}').join(' ');
    const sourceCode = types
        .map(node => {
        const { name } = node;
        const ctx = {
            rootTypes: types,
        };
        const tsNode = convertSingleCoreType(node, opts, ctx);
        convertedTypes.push(name);
        return tsNode;
    })
        .map(({ declaration: tsNode, namespaceList }) => wrapInNamespaces(generateCode(tsNode), namespaceList))
        .join("\n\n");
    const header = createCodeHeader({
        ...opts,
        createdByPackage,
        createdByUrl,
    });
    return {
        data: header +
            sourceCode +
            (sourceCode.endsWith("\n") ? "" : "\n"),
        convertedTypes,
        notConvertedTypes: [],
    };
}
export function convertSingleCoreTypeToTypeScriptAst(node, opts = {}) {
    const ctx = {
        rootTypes: [],
    };
    return convertSingleCoreType(node, opts, ctx);
}
export function convertSingleCoreType(node, opts, partialCtx) {
    const { useUnknown = false, declaration = false, namespaces = 'ignore', } = opts;
    const ctx = {
        ...partialCtx,
        useUnknown,
    };
    const { name, namespaces: namespaceList } = makeNameAndNamespace(node.name, namespaces);
    const ret = tsType(ctx, node, true);
    const doExport = (tsNode) => wrapAnnotations(tsNode, node);
    const typeDeclaration = ret.type === 'flow-type'
        ? declareType(declaration, name, ret.node)
        : declareInterface(declaration, name, ret.properties, ret.inherits);
    return {
        declaration: doExport(typeDeclaration),
        namespaceList,
    };
}
function makeNameAndNamespace(name, namespaces) {
    if (!namespaces || namespaces === 'ignore')
        return { name, namespaces: [] };
    const parts = name
        .split(namespaces === 'dot' ? '.' :
        namespaces === 'underscore' ? '_' :
            /[._]/);
    const lastPart = parts.pop();
    return { name: lastPart, namespaces: parts };
}
function createExportModifier(declaration) {
    return factory.createModifiersFromModifierFlags(declaration
        ? ts.ModifierFlags.Export | ts.ModifierFlags.Ambient
        : ts.ModifierFlags.Export);
}
function declareType(declaration, name, node) {
    return factory.createTypeAliasDeclaration(createExportModifier(declaration), // modifiers
    factory.createIdentifier(name), undefined, // type parameters
    node);
}
function declareInterface(declaration, name, nodes, inherits) {
    const heritage = inherits.length === 0
        ? undefined
        : [
            factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, inherits.map(name => factory.createExpressionWithTypeArguments(factory.createIdentifier(name), undefined // type arguments
            )))
        ];
    return factory.createInterfaceDeclaration(createExportModifier(declaration), // modifiers
    factory.createIdentifier(name), undefined, // type parameters
    heritage, nodes);
}
function tsTypeUnion(ctx, node) {
    return factory.createUnionTypeNode(node.or.map(elem => wrapAnnotations(tsTypeAndOrSchema(ctx, elem), elem)));
}
function tsTypeIntersection(ctx, node) {
    return factory.createIntersectionTypeNode(node.and.map(elem => wrapAnnotations(tsTypeAndOrSchema(ctx, elem), elem)));
}
function tsTypeAndOrSchema(ctx, node) {
    if (node.type === 'and' || node.type === 'or')
        return tsTypeAndOr(ctx, node);
    else
        return tsType(ctx, node).node;
}
function tsTypeAndOr(ctx, andOr) {
    if (andOr.type === 'and')
        return tsTypeIntersection(ctx, andOr);
    else
        return tsTypeUnion(ctx, andOr);
}
function tsAny(ctx) {
    return ctx.useUnknown
        ? tsUnknownTypeAnnotation()
        : factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
}
function tsType(ctx, node, topLevel = false) {
    if (topLevel && node.type === 'and' && isObjectWithHeritage(ctx, node))
        return { type: 'object', ...tsObjectTypeWithWithHeritage(ctx, node) };
    if (node.type === 'and' || node.type === 'or')
        return { type: 'flow-type', node: tsTypeAndOr(ctx, node) };
    if (node.type === 'null')
        return { type: 'flow-type', node: tsPrimitiveType(node) };
    const { const: _const, enum: _enum } = node;
    if (_const)
        return {
            type: 'flow-type',
            node: tsConstType(ctx, node, _const),
        };
    else if (_enum)
        return {
            type: 'flow-type',
            node: factory.createUnionTypeNode(_enum
                .map(elem => tsConstType(ctx, node, elem)))
        };
    if (isPrimitiveType(node))
        return { type: 'flow-type', node: tsPrimitiveType(node) };
    if (node.type === 'any')
        return {
            type: 'flow-type',
            node: tsAny(ctx),
        };
    if (node.type === 'ref')
        return { type: 'flow-type', node: tsRefType(node) };
    if (node.type === 'object')
        return { type: 'object', ...tsObjectType(ctx, node) };
    if (node.type === 'array' || node.type === 'tuple')
        return { type: 'flow-type', node: tsArrayType(ctx, node) };
    throwUnsupported(`Type ${node.type} not supported`, node);
}
function tsNullType() {
    return factory.createLiteralTypeNode(factory.createToken(ts.SyntaxKind.NullKeyword));
}
const primitiveTypeMap = {
    string: ts.SyntaxKind.StringKeyword,
    number: ts.SyntaxKind.NumberKeyword,
    integer: ts.SyntaxKind.NumberKeyword,
    boolean: ts.SyntaxKind.BooleanKeyword,
};
function tsPrimitiveType(node) {
    const { type } = node;
    if (type === "null")
        return tsNullType();
    else if (primitiveTypeMap[type])
        return factory.createKeywordTypeNode(primitiveTypeMap[type]);
    throwUnsupported(`Invalid primitive type: ${type}`, node);
}
function tsConstType(ctx, node, value) {
    return value === "null"
        ? tsNullType()
        : typeof value === "string"
            ? factory.createStringLiteral(value)
            : typeof value === "number"
                ? factory.createNumericLiteral(value)
                : typeof value === "boolean"
                    ? value ? factory.createTrue() : factory.createFalse()
                    : typeof value === "object"
                        ? Array.isArray(value)
                            ? tsArrayConstExpression(ctx, node, value)
                            : tsObjectType(ctx, value).node
                        : (() => {
                            throwUnsupported(`Invalid const value: "${value}"`, node, { blob: value });
                        })();
}
function tsArrayConstExpression(ctx, node, value) {
    return factory.createTupleTypeNode(value.map(elem => tsConstType(ctx, node, elem)));
}
function createAdditionalMembers(ctx, type) {
    if (type === true)
        return createAdditionalMembers(ctx, { type: 'any' });
    return factory.createIndexSignature(undefined, // modifiers
    [
        factory.createParameterDeclaration(undefined, // modifiers
        undefined, // dotdotdot token
        'key', undefined, // question token
        tsType(ctx, { type: 'string' }).node)
    ], tsType(ctx, type).node);
}
function tsObjectType(ctx, node) {
    const { properties, additionalProperties = false, } = node;
    const additionalEntry = additionalProperties === false ? []
        : [createAdditionalMembers(ctx, additionalProperties)];
    const createQuestionmark = (required) => required
        ? undefined
        : factory.createToken(ts.SyntaxKind.QuestionToken);
    const propertyNodes = [
        ...Object
            .keys(properties)
            .map(name => ({ name, ...properties[name] }))
            .map(({ name, node, required }) => wrapAnnotations(factory.createPropertySignature(undefined, // modifiers
        safeName(name), createQuestionmark(required), tsType(ctx, node).node), properties[name].node)),
        ...additionalEntry,
    ];
    const objectAsNode = factory.createTypeLiteralNode(propertyNodes);
    return { properties: propertyNodes, node: objectAsNode, inherits: [] };
}
// Extracts objects and refs from an and-type.
// Only refs that themselves are objects.
function getObjectsAndRefs(ctx, node) {
    const objects = node.and.filter((node) => node.type === 'object');
    const refs = node.and.filter((node) => node.type === 'ref'
        &&
            ctx.rootTypes.some(rootNode => rootNode.name === node.ref
                &&
                    rootNode.type === 'object'));
    return { objects, refs };
}
function isObjectWithHeritage(ctx, node) {
    const { objects, refs } = getObjectsAndRefs(ctx, node);
    if (objects.length !== 0 && objects.length !== 1)
        // Must have zero or one object with properties, not multiple
        return false;
    // And-type contains only refs and (maybe) an object, so it's an interface
    return objects.length + refs.length === node.and.length;
}
function tsObjectTypeWithWithHeritage(ctx, node) {
    const { objects, refs } = getObjectsAndRefs(ctx, node);
    const ret = objects.length === 0
        ? {
            properties: [],
            node: factory.createTypeLiteralNode([]),
            inherits: [],
        }
        : tsObjectType(ctx, objects[0]);
    return { ...ret, inherits: refs.map(node => node.ref) };
}
function tsSpreadType(ctx, node) {
    return factory.createArrayTypeNode(factory.createRestTypeNode(tsType(ctx, node).node));
}
function tsArrayType(ctx, node) {
    // TODO: Add support for minItems (making rest arguments optional)
    // TODO: Maybe add support for maxItems (turning an array into a tuple of
    //       some "good" max size)
    // Both are tricky for merged (anyOf, allOf, if-then-else) conditionals
    // if the types come from json schema...
    if (node.type === 'tuple')
        return factory.createTupleTypeNode([
            ...node.elementTypes.map(elem => tsType(ctx, elem).node),
            ...(!node.additionalItems
                ? []
                : node.additionalItems === true
                    ? [tsSpreadType(ctx, { type: 'any' })]
                    : [tsSpreadType(ctx, node.additionalItems)])
        ]);
    else
        return factory.createArrayTypeNode(tsType(ctx, node.elementType).node);
}
function tsRefType(node) {
    return factory.createTypeReferenceNode(node.ref);
}
