import { promises as fsPromises } from "fs";
import path from "path";
import { globby } from "globby";
import chalk from "chalk";
import terminalLink from "terminal-link";
export async function getSource(source) {
    if (source.data)
        return {
            data: source.data,
        };
    else if (source.filename && fsPromises.readFile)
        return {
            data: await fsPromises.readFile(source.filename, 'utf-8'),
            filename: source.filename,
        };
    throw new Error("Invalid source: " + JSON.stringify(source));
}
export async function writeFile(filename, data) {
    const tryWrite = () => fsPromises.writeFile(filename, data);
    try {
        await tryWrite();
    }
    catch (err) {
        if (err?.code === 'ENOENT') {
            await fsPromises.mkdir(path.dirname(filename), { recursive: true });
            await tryWrite();
        }
    }
}
export function relFile(from, to) {
    if (typeof from === 'undefined')
        return to;
    return path.relative(from, to);
}
export async function glob(globs, cwd, hidden = true) {
    const patterns = hidden ? [...globs, '!.git'] : globs;
    const dot = !hidden;
    const gitignore = hidden;
    return globby(patterns, { cwd, dot, gitignore });
}
export function ensureAbsolute(filename, cwd) {
    return path.isAbsolute(filename)
        ? filename
        : path.normalize(path.join(cwd, filename));
}
/**
 * Find the deepest common directory of a set of files.
 */
export function getRootFolderOfFiles(files, cwd) {
    const map = {};
    const last = new WeakMap();
    files
        .map(filename => ensureAbsolute(filename, cwd))
        .map(filename => path.dirname(filename))
        .forEach(dirname => {
        const dirSegments = dirname.split(path.sep);
        let cur = map;
        dirSegments.forEach(segment => {
            cur[segment] ?? (cur[segment] = {});
            cur = cur[segment];
        });
        last.set(cur, dirname);
    });
    let curPath = [];
    let cur = map;
    while (true) {
        const keys = Object.getOwnPropertyNames(cur);
        if (keys.length !== 1)
            return curPath.join(path.sep);
        else if (last.has(cur))
            return last.get(cur);
        cur = cur[keys[0]];
        curPath.push(keys[0]);
    }
}
/**
 * Get the common "root" directory of files, their relative path to this
 * directory, and their relative path to new root directory.
 */
export function reRootFiles(files, cwd, newRoot) {
    const root = getRootFolderOfFiles(files, cwd);
    const newAbsRoot = typeof newRoot === 'undefined'
        ? root
        : ensureAbsolute(newRoot, cwd);
    return {
        root,
        newRoot: newAbsRoot,
        files: files
            .map(filename => ensureAbsolute(filename, cwd))
            .map(filename => {
            const rel = path.relative(root, filename);
            const out = ensureAbsolute(rel, newAbsRoot);
            return { in: filename, out, rel };
        }),
    };
}
export function prettyFile(filename, cwd) {
    const absFile = 'file://' + ensureAbsolute(filename, cwd);
    const baseName = path.basename(filename);
    const dirName = path.dirname(filename);
    const name = ((dirName && dirName !== '.') ? (dirName + path.sep) : '') +
        chalk.bold(baseName);
    return terminalLink(name, absFile, { fallback: false });
}
