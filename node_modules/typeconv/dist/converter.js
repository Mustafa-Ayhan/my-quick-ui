import { decorateError, decorateErrorMeta, isCoreTypesError, simplify, } from "core-types";
import { getSource, writeFile, relFile } from "./file.js";
import { formatError } from "./error.js";
import { ConversionContext } from "./format-graph.js";
async function readSource(from, reader) {
    if (reader.managedRead) {
        const { filename } = from;
        if (!filename)
            throw new Error("Internal error, expected filename not data");
        return { filename };
    }
    return await getSource(from);
}
async function convertAny(data, reader, writer, format, readOpts, writeOpts) {
    if (format === 'ct') {
        const read = await reader.read(data, readOpts);
        const written = await writer.write(read.data, writeOpts);
        return {
            output: written.data,
            convertedTypes: read.convertedTypes,
            notConvertedTypes: read.notConvertedTypes,
            outConvertedTypes: written.convertedTypes,
            outNotConvertedTypes: written.notConvertedTypes,
        };
    }
    else {
        const read = await reader.shortcut[format](data, readOpts);
        const written = await writer.shortcut[format](read.data, writeOpts, reader);
        return {
            output: written.data,
            convertedTypes: read.convertedTypes,
            notConvertedTypes: read.notConvertedTypes,
            outConvertedTypes: written.convertedTypes,
            outNotConvertedTypes: written.notConvertedTypes,
        };
    }
}
export function makeConverter(reader, writer, options) {
    const { shortcut = true, cwd = process.cwd() } = options ?? {};
    const relFilename = (filename) => relFile(options?.cwd, filename);
    const context = new ConversionContext(reader, writer, { shortcut });
    const conversionPath = context.getPath();
    const simpleSingleConversion = conversionPath.length === 1 && conversionPath[0].format === 'ct';
    async function convert(from, to) {
        const { data, filename } = await readSource(from, reader);
        const dataOrFilename = (data ?? filename);
        const warn = (msg, meta) => {
            const fullMeta = decorateErrorMeta({ ...meta }, { filename, source: data });
            console.warn(formatError(msg, fullMeta));
        };
        const toFilename = to?.relFilename ?? relFilename(to?.filename ?? '');
        const readOpts = {
            warn,
            filename: filename ? relFilename(filename) : undefined,
        };
        const writeOpts = {
            warn,
            ...(to
                ? { filename: toFilename }
                : {}),
            ...(filename
                ? { sourceFilename: relFilename(filename) }
                : {}),
            rawInput: data,
        };
        const convertByGraphPath = async (data, pathIndex) => {
            const { reader, writer, format } = conversionPath[pathIndex];
            const result = await convertAny(data, reader, writer, format, readOpts, writeOpts);
            const uniqAppend = (a, b) => [...new Set(a), ...new Set(b)];
            if (conversionPath.length > pathIndex + 1) {
                // Recurse - follow path and convert again
                const recursionResult = await convertByGraphPath(result.output, pathIndex + 1);
                return {
                    output: recursionResult.output,
                    convertedTypes: recursionResult.convertedTypes,
                    notConvertedTypes: uniqAppend(result.notConvertedTypes, recursionResult.notConvertedTypes),
                    outConvertedTypes: recursionResult.convertedTypes,
                    outNotConvertedTypes: uniqAppend(result.outNotConvertedTypes, recursionResult.outNotConvertedTypes),
                };
            }
            else {
                return result;
            }
        };
        const convertDefault = async () => {
            const { data: doc, convertedTypes, notConvertedTypes } = await reader.read(dataOrFilename, readOpts);
            const simplifiedDoc = options?.simplify === false
                ? doc
                : simplify(doc, { mergeObjects: options?.mergeObjects });
            const { map, filter, transform } = options ?? {};
            const mappedDoc = typeof map === 'function'
                ? {
                    ...simplifiedDoc,
                    types: doc.types.map((type, index) => map(type, index, doc.types)),
                }
                : simplifiedDoc;
            const filteredDoc = typeof filter === 'function'
                ? {
                    ...mappedDoc,
                    types: doc.types.filter((type, index) => filter(type, index, doc.types)),
                }
                : mappedDoc;
            const finalDoc = typeof transform === 'function'
                ? transform(filteredDoc)
                : filteredDoc;
            const { data: output, convertedTypes: outConvertedTypes, notConvertedTypes: outNotConvertedTypes } = await writer.write(finalDoc, writeOpts);
            return {
                output,
                convertedTypes,
                notConvertedTypes,
                outConvertedTypes,
                outNotConvertedTypes,
            };
        };
        try {
            const { output, convertedTypes, notConvertedTypes, outConvertedTypes, outNotConvertedTypes, } = simpleSingleConversion
                ? await convertDefault()
                : await convertByGraphPath(dataOrFilename, 0);
            const info = {
                in: { convertedTypes, notConvertedTypes },
                out: {
                    convertedTypes: outConvertedTypes,
                    notConvertedTypes: outNotConvertedTypes,
                },
            };
            if (typeof to?.filename === 'undefined')
                return { data: output, ...info };
            // Only write non-empty files
            if (outConvertedTypes.length > 0)
                await writeFile(to?.filename, output);
            return info;
        }
        catch (err) {
            if (isCoreTypesError(err))
                decorateError(err, {
                    source: data,
                    ...(filename ? { filename } : {}),
                });
            throw err;
        }
    }
    const fromFormat = reader.kind;
    return { convert: convert, cwd, fromFormat };
}
