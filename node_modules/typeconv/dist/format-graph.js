export function makePathKey(path) {
    return path
        .map(({ format, reader, writer }) => `${reader.kind}->{${format}}->${writer.kind}`)
        .join('  ');
}
export class FormatGraph {
    constructor() {
        // Maps from-type -> (type-type -> reader)
        this.readerGraph = new Map();
        // Maps from-type -> (type-type -> writer)
        this.writerGraph = new Map();
    }
    registerReader(reader) {
        const toMap = [
            ['ct', reader],
            ...Object
                .keys(reader.shortcut ?? {})
                .map((key) => [key, reader]),
        ];
        this.readerGraph.set(reader.kind, new Map(toMap));
    }
    registerWriter(writer) {
        const makeTo = () => [writer.kind, writer];
        const insertWriter = (from) => {
            const old = [...this.writerGraph.get(from) ?? []];
            this.writerGraph.set(from, new Map([...old, makeTo()]));
        };
        insertWriter('ct');
        Object
            .keys(writer.shortcut ?? {})
            .forEach(key => insertWriter(key));
    }
    findAllPaths(reader, writer, shortcuts) {
        const paths = new Map();
        const appendSet = (set, val) => new Set([...set, val]);
        const recurse = (reader, path, opts) => {
            const { allowManaged = false, cache } = opts;
            const handleFound = (writer, format) => {
                if (reader.managedRead && !allowManaged)
                    return;
                const newPath = [...path, { reader, writer, format }];
                const pathKey = makePathKey(newPath);
                paths.set(pathKey, newPath);
            };
            const formats = [
                ...shortcuts ? [] : ['ct'],
                ...shortcuts !== false
                    ? Object.keys(reader.shortcut ?? {})
                    : []
            ];
            for (const format of formats) {
                const writers = this.writerGraph.get(format);
                for (const [to, _writer] of writers?.entries() ?? []) {
                    if (writer.kind === _writer.kind)
                        handleFound(writer, format);
                    else if (reader.kind === _writer.kind)
                        continue;
                    else {
                        // Find readers and recurse
                        const readers = this.readerGraph.get(to);
                        for (const _reader of readers?.values() ?? []) {
                            if (_reader.managedRead && !allowManaged)
                                continue;
                            else if (cache.has(_reader))
                                continue; // Cyclic
                            recurse(_reader, [...path, { reader, writer: _writer, format }], {
                                cache: appendSet(cache, _reader),
                            });
                        }
                    }
                }
            }
        };
        recurse(reader, [], { allowManaged: true, cache: new Set() });
        return [...paths.values()].sort((a, b) => a.length - b.length);
    }
    findBestPath(reader, writer, shortcut) {
        const paths = this.findAllPaths(reader, writer, shortcut);
        if (paths.length > 0)
            return paths[0];
        // Allow all, find shortest path
        return this.findAllPaths(reader, writer, undefined)[0];
    }
    clone() {
        const clone = new FormatGraph();
        const readers = [...this.readerGraph.values()]
            .flatMap(map => [...map.values()]);
        const writers = [...this.writerGraph.values()]
            .flatMap(map => [...map.values()]);
        readers.forEach(reader => clone.registerReader(reader));
        writers.forEach(writer => clone.registerWriter(writer));
        return clone;
    }
}
const defaultGraph = new FormatGraph();
export function registerReader(reader) {
    defaultGraph.registerReader(reader);
}
export function registerWriter(writer) {
    defaultGraph.registerWriter(writer);
}
export class ConversionContext {
    constructor(reader, writer, opts = {}) {
        this.reader = reader;
        this.writer = writer;
        this.shortcut = opts.shortcut;
        this.graph = defaultGraph.clone();
        this.graph.registerReader(reader);
        this.graph.registerWriter(writer);
    }
    getPath() {
        return this.graph.findBestPath(this.reader, this.writer, this.shortcut);
    }
}
