{"version":3,"file":"fileHelper.js","sourceRoot":"","sources":["../../src/helpers/fileHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport { IFileInfo } from \"../interfaces/IFileNetworkMessage\";\nimport * as path from \"path\";\nimport { Logger } from \"./logger\";\nimport { LogLevel } from \"../interfaces/ILogItem\";\nimport { colors } from \"./colors\";\n\nexport interface IExportFileSettings {\n    sourcePath: string;\n    targetPath: string;\n    replaceMap: Map<RegExp, string>;\n}\n\nexport enum ItemType {\n    Directory,\n    File,\n    FIFO,\n    Socket,\n    SymbolicLink\n}\n\nexport class FileHelper {\n    private static slashCache?: string;\n    private static discardReplacementExt = [\".jar\"];\n    public static get Slash(): string {\n        return FileHelper.slashCache || (FileHelper.slashCache = path.resolve(\"/\") == path.posix.resolve(\"/\") ? \"/\" : \"\\\\\");\n    }\n\n    public static removeDist() {\n        this.deleteFolderRecursive({ path: \"./dist\" });\n    }\n\n    public static removeFolder(path: string) {\n        this.deleteFolderRecursive({ path });\n    }\n\n    private static deleteFolderRecursive({ path, deleteRootPath }: { path: string, deleteRootPath?: boolean }) {\n        Logger.log({ message: \"Dist file cleaning is started...\", level: LogLevel.log });\n        const rootPath = path;\n\n        const deleteRecursiveFunc = (path: string) => {\n            if (!fs.existsSync(path)) {\n                //Logger.log({ message: \"The path not exists: \" + path, level: LogLevel.log });\n                return;\n            }\n\n            fs.readdirSync(path).forEach(function (file, index) {\n                var curPath = path + \"/\" + file;\n                if (fs.lstatSync(curPath).isDirectory()) {\n                    deleteRecursiveFunc(curPath);\n                }\n                else {\n                    //Logger.log({ message: \"Deleting item: \" + curPath, level: LogLevel.log });\n                    fs.unlinkSync(curPath);\n                }\n            });\n\n            if (!deleteRootPath && rootPath == path) {\n                //Logger.log({ message: \"Passing the root path...\", level: LogLevel.log });\n                return;\n            }\n            //Logger.log({ message: \"Deleting item: \" + path, level: LogLevel.log });\n            fs.rmdirSync(path);\n\n        };\n\n        deleteRecursiveFunc(path);\n        Logger.log({ message: \"Dist file cleaning is finished...\", level: LogLevel.log });\n    }\n\n    private static exportFilesInner(settings: IExportFileSettings) {\n        fs.readdirSync(settings.sourcePath).forEach(item => {\n            let itemReplaced: string = item;\n            settings.replaceMap.forEach(function (newstring, old) {\n                itemReplaced = itemReplaced.replace(old, newstring);\n            })\n\n            const sourceItem = path.join(settings.sourcePath, item);\n            const targetItem = path.join(settings.targetPath, itemReplaced);\n\n            const data = fs.lstatSync(sourceItem);\n            if (data.isDirectory()) {\n                fs.mkdirSync(targetItem, { recursive: true });\n                //Logger.log({ message: `${targetItem} is saved.`});\n\n                this.exportFilesInner({ sourcePath: sourceItem, targetPath: targetItem, replaceMap: settings.replaceMap });\n            } else {\n                const ext = path.extname(sourceItem);\n\n                if (this.discardReplacementExt.indexOf(ext) > -1) {\n                    Logger.log({ message: `${colors.green}${colors.bold}Replacement skipping for ${targetItem}${colors.reset}` });\n                    const data = fs.readFileSync(sourceItem);\n                    fs.writeFileSync(targetItem, data);\n                    return;\n                }\n\n                let data = fs.readFileSync(sourceItem, \"utf8\");\n                settings.replaceMap.forEach(function (newstring, old) {\n                    data = data.replace(old, newstring);\n                })\n\n                fs.writeFileSync(targetItem, data, 'utf8');\n                //Logger.log({ message: `${targetItem} is saved.` });\n\n            }\n        });\n    }\n\n    public static exportFiles(settings: IExportFileSettings) {\n        Logger.log({ message: `${colors.green}${colors.bold}Files copying...${colors.reset}` });\n\n        this.exportFilesInner(settings);\n\n        Logger.log({ message: `${colors.green}${colors.bold}Files copied successfully.${colors.reset}` });\n\n    }\n\n    public static getFileNamesFormPath({ selectedPath, excludeFolders, selectedExtensions }: { selectedPath: string, excludeFolders?: boolean, selectedExtensions?: string[] }): IFileInfo[] {\n        let retVal: IFileInfo[] = [];\n\n        const isSelectedExtension = (extension: string, selectedExtensions?: string[]): boolean => {\n            if (!selectedExtensions) {\n                return true; //Özellikle seçilecek extension belirtmediyse hepsini listeye ekleyebiliriz.\n            }\n\n            return selectedExtensions.indexOf(extension) > -1\n                || selectedExtensions.indexOf(extension.substring(1, extension.length)) > -1;\n        }\n\n        const files = fs.readdirSync(path.resolve(selectedPath));\n        files.forEach(name => {\n            const ext = path.extname(name);\n            const isDirectory = this.isDirectory(path.join(selectedPath, name));\n            //Folder ignore check\n            if (isDirectory && !excludeFolders) {\n                retVal.push({ name, type: \"folder\" });\n            }\n            //Selected extensions check\n            else if (isSelectedExtension(ext, selectedExtensions)) {\n                retVal.push({ name: path.basename(name, ext), ext, type: \"file\" });\n            }\n        });\n\n        return retVal;\n    }\n\n    public static isDirectory(itemPath: string): boolean {\n        // Why try-catch?: https://stackoverflow.com/a/33401005\n        try {\n            const stat = fs.statSync(itemPath);\n            return stat.isDirectory();\n        }\n        catch {\n            return false;\n        }\n    }\n\n}"]}