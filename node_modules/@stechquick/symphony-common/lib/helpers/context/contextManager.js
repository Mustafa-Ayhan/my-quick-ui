"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextManager = void 0;
class ContextManager {
    constructor() {
        this.contextItems = {};
    }
    /**
     * Register item to context
     * @param item item to register
     */
    RegisterItem(item, options = { override: false }) {
        let contextGroup = this.contextItems[item.contextName];
        if (!contextGroup || options.override) {
            contextGroup = [];
            this.contextItems[item.contextName] = contextGroup;
        }
        contextGroup.push(item);
    }
    GetOrCreate(contextItemName, contextCreatorCb) {
        let contextItem = this.GetItemSingle(contextItemName);
        if (!contextItem) {
            contextItem = contextCreatorCb();
            this.RegisterItem(contextItem);
        }
        return contextItem;
    }
    /**
     * @deprecated use -> GetItemSingle. Careful -> returns undefined. Use ! if must exist
     */
    GetItem(contextItemName) {
        return this.GetItemSingle(contextItemName) || null;
        //Delete on 22.02.2021
        // const contextGroup = this.GetItemGroup<contextItemType>(contextItemName);
        // if (!contextGroup) {
        //     return null as unknown as contextItemType;
        // }
        // return <contextItemType>contextGroup[contextGroup.length - 1]; //contextItem.name
    }
    /**
     * Gets last Item. Use ! if it must exist.
     */
    GetItemSingle(contextItemName) {
        const contextGroup = this.GetItemGroup(contextItemName);
        if (!contextGroup) {
            return undefined;
        }
        return contextGroup[contextGroup.length - 1]; //contextItem.name
    }
    GetItemGroup(contextItemName) {
        return this.contextItems[contextItemName] || null;
    }
    ClearItemGroup(contextItemName) {
        delete this.contextItems[contextItemName];
    }
    ClearItem(c) {
        const itemGroup = this.GetItemGroup(c.contextName);
        if (!itemGroup) {
            return;
        }
        const itemIndex = itemGroup.indexOf(c);
        itemGroup.splice(itemIndex, 1);
    }
    /**
     * Shallow copy of self
     * @param fields if specified, only puts those fields in the clone
     */
    Clone(fields) {
        const contextCopy = new ContextManager();
        const keys = fields !== null && fields !== void 0 ? fields : Object.keys(this.contextItems);
        keys.forEach(contextKey => contextCopy.contextItems[contextKey] = this.contextItems[contextKey].map(item => item));
        return contextCopy;
    }
    /**
     * Get Contexts registered context item keys
     */
    GetKeys() {
        return Object.keys(this.contextItems);
    }
}
exports.ContextManager = ContextManager;
//# sourceMappingURL=contextManager.js.map