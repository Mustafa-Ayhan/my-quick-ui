/**
 * Action'ların key üzerinden ayrılması.
 *  Key <TKey> olabilir, Record<string, string> -> obje alanları concat ederek string key elde edilir, adama verirken TKey'den verilir
 * Backend timing'in client performans alanına yazdırılması
 * capture | mock | off from terminal
 * Action'lara cache setting
 * Action'ların pre ve post'u
 * Sym-Lib üzerinden Pipeline'a tüm actionlar için genel pre ve post. Actionlar TKey ile merkezi ayrıştırılabilir.
 */
interface IReportBase {
    key: string;
    success: boolean;
    /**
     * total time in ms
     */
    total: number;
    /**
     * elapsed miliseconds since midnight 1.1.1970 in UTC
     * @see Date.now
     */
    startTime: number;
    finished: boolean;
}
interface IActionReport extends IReportBase {
}
interface IExecutionReport extends IReportBase {
    actions: Array<IActionReport>;
}
interface IActionOptions {
    enableParalelStart?: boolean;
}
export interface IAction {
    isStarted: boolean;
    scope<TReturnType>(cb: () => Promise<TReturnType>): Promise<TReturnType>;
    start(): void;
    end(options?: {
        error?: unknown;
    }): void;
    report(): IActionReport;
}
declare class Action implements IAction {
    private readonly key;
    private readonly options;
    private parts;
    constructor(key: string, options: IActionOptions);
    get isStarted(): boolean;
    private getFirst;
    private getLast;
    scope<TReturnType>(cb: () => Promise<TReturnType>): Promise<TReturnType>;
    start(): void;
    end(options?: {
        error?: unknown;
    }): void;
    report(): IActionReport;
}
export declare class Execution {
    readonly key: string;
    static startExecutionScope<TReturnType>(key: string, cb: (execution: Execution) => Promise<TReturnType>): Promise<TReturnType>;
    readonly startTime: number;
    endTime?: number;
    error?: unknown;
    endReport?: IExecutionReport;
    private actions;
    private counterDict;
    constructor(key: string);
    private assertNotEnded;
    private scope;
    end(options?: {
        error?: unknown;
    }): void;
    startActionScope<TReturnType>(options: {
        key: string;
        transient?: boolean;
        appendCounterToKey?: boolean;
    }, cb: () => Promise<TReturnType>): Promise<TReturnType>;
    /**
     *
     * @param options {transient: action will not be reported, appendCounterToKey: manage an auto incremented counter for key and append it to key, enableParalelStart: enable multiple start calls}
     */
    startAction(key: string, options?: {
        doNotStart?: boolean;
        transient?: boolean;
        appendCounterToKey?: boolean;
        enableParalelStart?: boolean;
    }): Action;
    private createAction;
    report(): IExecutionReport;
}
export {};
//# sourceMappingURL=executionHelper.d.ts.map