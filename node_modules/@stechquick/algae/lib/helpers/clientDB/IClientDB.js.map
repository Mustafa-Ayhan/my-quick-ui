{"version":3,"file":"IClientDB.js","sourceRoot":"","sources":["../../../src/helpers/clientDB/IClientDB.ts"],"names":[],"mappings":";;;AAKC,CAAC;AAwEW,QAAA,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC","sourcesContent":["export type IClientDBVersion = number;\n\nexport interface IClientDBIndexOptions {\n    readonly unique?: boolean;\n    readonly multiEntry?: boolean;\n};\nexport type IClientDBIndexes<TStore> = {\n    [K in keyof TStore]?: IClientDBIndexOptions;\n}\n\nexport interface IClientDBUpgraderStore {\n    getIndex(name: string): IClientDBIndexOptions | undefined;\n    deleteIndex(name: string): void;\n}\nexport interface IClientDBCreateStoreOptions<TStore> {\n    keyPath?: keyof TStore | Array<keyof TStore>;\n    indexes?: IClientDBIndexes<TStore>;\n    reCreatePermittedIfKeyMismatch?: boolean;\n}\nexport interface IClientDBUpgrader {\n    createStore<TStore>(storeName: string, options?: IClientDBCreateStoreOptions<TStore>): void;\n    deleteStore(storeName: string): void;\n    storeExists(storeName: string): boolean;\n    getStore(storeName: string): IClientDBUpgraderStore | undefined;\n}\n\nexport type ClientDBQueryOptions<QType extends \"single\" | \"multi\"> = { type: QType } & (QType extends \"single\" ? {} : { count?: number });\nexport interface IClientDBStoreReadOnly<T> {\n    query<QType extends \"single\" | \"multi\">(key: string | Array<string> | IDBKeyRange, options: ClientDBQueryOptions<QType>): Promise<QType extends \"single\" ? T : Array<T>>;\n    allRecords(): Promise<Array<T>>;\n}\nexport interface IClientDBStoreReadWrite<T> extends IClientDBStoreReadOnly<T> {\n    insert(value: T, type: \"upsert\" | \"add or fail\", key?: string): Promise<void>;\n    delete(key: string | Array<string> | IDBKeyRange): Promise<void>;\n}\n\nexport interface IClientDBTransactionReadOnlySingle {\n    getStore<T>(): IClientDBStoreReadOnly<T>;\n}\nexport interface IClientDBTransactionReadWriteSingle extends IClientDBTransactionReadOnlySingle {\n    getStore<T>(): IClientDBStoreReadWrite<T>\n}\nexport interface IClientDBTransactionReadOnlyMultiple {\n    getStore<T>(storeName: string): IClientDBStoreReadOnly<T>;\n}\nexport interface IClientDBTransactionReadWriteMultiple extends IClientDBTransactionReadOnlyMultiple {\n    getStore<T>(storeName: string): IClientDBStoreReadWrite<T>\n}\n\nexport type ClientDBTransactionTypeSingle = {\n    readwrite: IClientDBTransactionReadWriteSingle,\n    readonly: IClientDBTransactionReadOnlySingle,\n}\nexport type ClientDBTransactionTypeMultiple = {\n    readwrite: IClientDBTransactionReadWriteMultiple,\n    readonly: IClientDBTransactionReadOnlyMultiple,\n}\nexport type singleScopeCB<TMode extends keyof ClientDBTransactionTypeSingle, TRetval> = (tx: ClientDBTransactionTypeSingle[TMode]) => TRetval | Promise<TRetval>;\nexport type multiScopeCB<TMode extends keyof ClientDBTransactionTypeMultiple, TRetval> = (tx: ClientDBTransactionTypeMultiple[TMode]) => TRetval | Promise<TRetval>;\nexport interface IClientDBConnection {\n    closeDB(): void;\n    scope<TMode extends keyof ClientDBTransactionTypeSingle, TRetval>(storeName: string, mode: TMode, cb: singleScopeCB<TMode, TRetval>): Promise<TRetval>;\n    scope<TMode extends keyof ClientDBTransactionTypeMultiple, TRetval>(storeName: Array<string>, mode: TMode, cb: multiScopeCB<TMode, TRetval>): Promise<TRetval>;\n}\nexport type IClientDBUpgradeNeededCB = (upgrader: IClientDBUpgrader, version: { old: number, new: number }) => Promise<void> | void;\nexport interface IClientDBOpenOptions {\n    upgradeNeeded: IClientDBUpgradeNeededCB;\n}\nexport interface IClientDBInfo {\n    name: string | undefined;\n    version: IClientDBVersion | undefined;\n}\nexport interface IClientDB {\n    listDatabases(): Promise<Array<IClientDBInfo>>;\n    openDB(dbName: string, version: IClientDBVersion, options: IClientDBOpenOptions): Promise<IClientDBConnection>;\n    deleteDB(dbName: string): void;\n}\nexport const IClientDB = Symbol.for(\"IClientDB\");"]}