{"version":3,"file":"clientDB.js","sourceRoot":"","sources":["../../../src/helpers/clientDB/clientDB.ts"],"names":[],"mappings":"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","sourcesContent":["import { CreatePromiseData } from \"../createPromiseData\";\nimport { IClientDB, IClientDBOpenOptions, IClientDBConnection, IClientDBUpgrader, IClientDBVersion, IClientDBStoreReadOnly, IClientDBStoreReadWrite, IClientDBTransactionReadOnlyMultiple, IClientDBTransactionReadOnlySingle, IClientDBTransactionReadWriteMultiple, IClientDBTransactionReadWriteSingle, IClientDBUpgraderStore, IClientDBIndexOptions, IClientDBIndexes, ClientDBQueryOptions, IClientDBInfo, IClientDBCreateStoreOptions } from \"./IClientDB\";\n\ninterface ILogItem {\n    level: \"debug\" | \"info\" | \"log\" | \"warning\" | \"error\";\n    message: string;\n    error?: unknown;\n    additionals?: Array<any>;\n}\ninterface ILogger {\n    log(logItem: ILogItem): void;\n}\n\nclass ClientDBUpgraderStore implements IClientDBUpgraderStore {\n    constructor(\n        private readonly store: IDBObjectStore,\n    ) { }\n    public getIndex(name: string): IClientDBIndexOptions | undefined {\n        if (!this.store.indexNames.contains(name)) { return undefined; }\n        const index = this.store.index(name)\n        return { multiEntry: index.multiEntry, unique: index.unique };\n    }\n    public deleteIndex(name: string) {\n        this.store.deleteIndex(name);\n    }\n}\nclass ClientDBUpgrader implements IClientDBUpgrader {\n    constructor(\n        private readonly db: IDBDatabase,\n        private readonly tx: IDBTransaction,\n    ) { }\n    public createStore<TStore>(storeName: string, options: IClientDBCreateStoreOptions<TStore> = {}) {\n        const { indexes } = options;\n        const keyPath = options.keyPath instanceof Array ? options.keyPath.map(keyPath => keyPath.toString()) : options.keyPath?.toString();\n        function createTable({ reCreate, db }: { db: IDBDatabase, reCreate: boolean }) {\n            if (reCreate) {\n                if (!options.reCreatePermittedIfKeyMismatch){\n                    const keys = { old: store.keyPath, new: keyPath };\n                    throw new Error(`Store ${storeName} reCreate is not permitted for key mismatch. keys: ${JSON.stringify(keys)}`);\n                }\n                db.deleteObjectStore(storeName);\n            }\n            return db.createObjectStore(storeName, { keyPath });\n        }\n        let store = this.getStorePriv(storeName) ?? createTable({ db: this.db, reCreate: false });\n        if (keyPath) {\n            if (keyPath instanceof Array != store.keyPath instanceof Array) { // type mismatch\n                store = createTable({ db: this.db, reCreate: true });\n            } else if (keyPath.length != store.keyPath.length) { // (array | string).length mismatch\n                store = createTable({ db: this.db, reCreate: true });\n            } else if (keyPath instanceof Array) { // both array\n                const keyMismatch = keyPath.find((curKeyPath, index) => store.keyPath[index] != curKeyPath);\n                if (keyMismatch) { store = createTable({ db: this.db, reCreate: true }); }\n            } else { // both string\n                if (keyPath != store.keyPath) {\n                    store = createTable({ db: this.db, reCreate: true });\n                }\n            }\n        }\n        function deleteIndex(name: string) { store.deleteIndex(name); }\n        function createIndex(name: string, options: IClientDBIndexOptions) { store.createIndex(name, name, options); }\n        function recreateIndex(oldIndex: IDBIndex, newIndex: IClientDBIndexOptions) {\n            if (newIndex.unique == oldIndex.unique && oldIndex.multiEntry == newIndex.multiEntry) { return; }\n            deleteIndex(oldIndex.name);\n            createIndex(oldIndex.name, newIndex);\n        }\n        indexes && Object.keys(indexes).forEach(indexName => {\n            const newIndex = indexes[indexName as keyof typeof indexes]!; // ! -> iterating indexes, obviously indexName is a key\n            if (!store.indexNames.contains(indexName)) { createIndex(indexName, newIndex); return; }\n\n            const oldIndex = store.index(indexName);\n            recreateIndex(oldIndex, newIndex);\n        });\n        Array.from(store.indexNames).forEach(indexName => {\n            if (!indexes) { deleteIndex(indexName); return; }\n\n            const newIndex = indexes[indexName as keyof typeof indexes];\n            if (!newIndex) { deleteIndex(indexName); return; }\n\n            const oldIndex = store.index(indexName);\n            recreateIndex(oldIndex, newIndex);\n        });\n    }\n    public deleteStore(storeName: string) {\n        this.db.deleteObjectStore(storeName);\n    }\n    public storeExists(storeName: string): boolean {\n        return this.getStore(storeName) != undefined;\n    }\n    public getStorePriv(storeName: string) {\n        if (!this.db.objectStoreNames.contains(storeName)) { return undefined; }\n        return this.tx.objectStore(storeName);\n    }\n    public getStore(storeName: string) {\n        const store = this.getStorePriv(storeName);\n        if (!store) { return undefined };\n        return new ClientDBUpgraderStore(store);\n    }\n}\nclass ClientDBStoreReadOnly<T> implements IClientDBStoreReadOnly<T>{\n    constructor(\n        protected readonly store: IDBObjectStore,\n    ) { }\n\n    public allRecords() {\n        return this.queryPrivate(undefined, { type: \"multi\" });\n    }\n    public query<QType extends \"single\" | \"multi\">(key: string | Array<string> | IDBKeyRange, options: ClientDBQueryOptions<QType>) {\n        return this.queryPrivate(key, options);\n    }\n    private queryPrivate<QType extends \"single\" | \"multi\">(key: QType extends \"single\" ? string | Array<string> | IDBKeyRange : string | Array<string> | IDBKeyRange | undefined, options: ClientDBQueryOptions<QType>) {\n        const prom = CreatePromiseData<QType extends \"single\" ? T : Array<T>>();\n        const request = options.type == \"single\"\n            ? this.store.get(key as string | Array<string> | IDBKeyRange)\n            : this.store.getAll(key, (options as ClientDBQueryOptions<\"multi\">).count);\n        request.addEventListener(\"success\", ev => {\n            prom.resolver((ev.target as IDBRequest<QType extends \"single\" ? T : Array<T>>).result);\n        });\n        request.addEventListener(\"error\", ev => {\n            prom.reject((ev.target as typeof request).error);\n        });\n        return prom.promise;\n    }\n}\nclass ClientDBStoreReadWrite<T> extends ClientDBStoreReadOnly<T> implements IClientDBStoreReadWrite<T>{\n    public async insert(value: T, type: \"upsert\" | \"add or fail\", key?: string) {\n        const prom = CreatePromiseData<void>();\n        const request = type == \"upsert\" ? this.store.put(value, key) : this.store.add(value, key);\n        request.addEventListener(\"success\", ev => { prom.resolver(); });\n        request.addEventListener(\"error\", ev => { prom.reject((ev.target as typeof request).error); });\n    }\n    public async delete(key: string | Array<string> | IDBKeyRange) {\n        const prom = CreatePromiseData<void>();\n        const request = this.store.delete(key);\n        request.addEventListener(\"success\", ev => { prom.resolver(); });\n        request.addEventListener(\"error\", ev => { prom.reject((ev.target as typeof request).error); });\n    }\n}\n\nclass ClientDBTransactionReadOnly implements IClientDBTransactionReadOnlySingle, IClientDBTransactionReadOnlyMultiple {\n    constructor(\n        private readonly tx: IDBTransaction,\n        private readonly storeNames: string | Array<string>,\n    ) { }\n\n    protected createInternaltStore(storeName?: string) {\n        let storeNamePriv = storeName;\n        if (!storeNamePriv) {\n            if (this.storeNames instanceof Array) { throw new Error(); }\n            storeNamePriv = this.storeNames;\n        }\n\n        return this.tx.objectStore(storeNamePriv);\n    }\n    public getStore<T>(storeName?: string) {\n        return new ClientDBStoreReadOnly<T>(this.createInternaltStore(storeName));\n    }\n}\nclass ClientDBTransactionReadWrite extends ClientDBTransactionReadOnly implements IClientDBTransactionReadWriteSingle, IClientDBTransactionReadWriteMultiple {\n    public getStore<T>(storeName?: string) {\n        return new ClientDBStoreReadWrite<T>(this.createInternaltStore(storeName));\n    }\n}\n\nconst clientDBTransactionDict = {\n    readonly: ClientDBTransactionReadOnly,\n    readwrite: ClientDBTransactionReadWrite,\n};\ntype scopeCB<TRetval> = (tx: ClientDBTransactionReadOnly | ClientDBTransactionReadWrite) => TRetval;\n\n\nclass ClientDBConnection implements IClientDBConnection {\n    constructor(\n        private readonly db: IDBDatabase,\n    ) { }\n\n    public closeDB() {\n        this.db.close();\n    }\n\n\n    public async scope<TMode extends keyof typeof clientDBTransactionDict, TRetval>(storeNames: string | Array<string>, mode: TMode, cb: scopeCB<TRetval>) {\n        const prom = CreatePromiseData<void>();\n        const transaction = this.db.transaction(storeNames, mode);\n        transaction.addEventListener(\"complete\", (ev) => { prom.resolver(); });\n        transaction.addEventListener(\"error\", (ev) => { prom.reject((ev.target as typeof transaction).error) });\n        transaction.addEventListener(\"abort\", (ev) => { prom.reject((ev.target as typeof transaction).error) });\n\n        try {\n            const tx = new clientDBTransactionDict[mode](transaction, storeNames);\n            const retVal = await cb(tx);\n            transaction.commit();\n            await prom.promise;\n            return retVal;\n        } finally {\n            this.closeDB();\n        }\n    }\n}\n\nexport class ClientDB implements IClientDB {\n    constructor(\n        private readonly logger: ILogger,\n    ) { }\n\n    public async listDatabases() {\n        const dbList = await indexedDB.databases();\n        return dbList.map<IClientDBInfo>((db) => {\n            return {\n                name: db.name,\n                version: db.version,\n            };\n        });\n    }\n    public openDB(dbName: string, version: IClientDBVersion, options: IClientDBOpenOptions) {\n        const prom = CreatePromiseData<IClientDBConnection>();\n        const request = indexedDB.open(dbName, version);\n        request.addEventListener(\"error\", ev => {\n            const message = `error opening db: ${dbName} v: ${version}`;\n            const error = (ev.target as typeof request).error;\n            this.logger.log({ level: \"error\", message, error });\n            prom.reject(error);\n        });\n        request.addEventListener(\"upgradeneeded\", async ev => {\n            this.logger.log({ level: \"warning\", message: `db upgrading from: ${ev.oldVersion} to ${ev.newVersion}]` });\n            const target = (ev.target as typeof request);\n            const db = target.result;\n            const tx = target.transaction!; // ! -> this is an open request\n            try {\n                await options.upgradeNeeded(new ClientDBUpgrader(db, tx), { new: ev.newVersion as IClientDBVersion, old: ev.oldVersion });\n            } catch (ex) {\n                this.logger.log({ level: \"error\", error: ex, message: \"error on upgrade\" });\n                tx.abort();\n                throw ex;\n            }\n            //ev.preventDefault();\n        });\n        request.addEventListener(\"success\", ev => {\n            const db = (ev.target as typeof request).result;\n            prom.resolver(new ClientDBConnection(db));\n        });\n        return prom.promise;\n    }\n\n    public deleteDB(dbName: string) {\n        const prom = CreatePromiseData<void>();\n        const request = indexedDB.deleteDatabase(dbName);\n        request.addEventListener(\"error\", ev => {\n            const message = `error deleting db: ${dbName}`;\n            const error = (ev.target as typeof request).error;\n            this.logger.log({ level: \"error\", message, error });\n            prom.reject(error);\n        });\n        request.addEventListener(\"success\", ev => {\n            prom.resolver();\n        });\n    }\n}"]}