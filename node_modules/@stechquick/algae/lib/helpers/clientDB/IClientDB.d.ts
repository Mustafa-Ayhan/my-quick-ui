export declare type IClientDBVersion = number;
export interface IClientDBIndexOptions {
    readonly unique?: boolean;
    readonly multiEntry?: boolean;
}
export declare type IClientDBIndexes<TStore> = {
    [K in keyof TStore]?: IClientDBIndexOptions;
};
export interface IClientDBUpgraderStore {
    getIndex(name: string): IClientDBIndexOptions | undefined;
    deleteIndex(name: string): void;
}
export interface IClientDBCreateStoreOptions<TStore> {
    keyPath?: keyof TStore | Array<keyof TStore>;
    indexes?: IClientDBIndexes<TStore>;
    reCreatePermittedIfKeyMismatch?: boolean;
}
export interface IClientDBUpgrader {
    createStore<TStore>(storeName: string, options?: IClientDBCreateStoreOptions<TStore>): void;
    deleteStore(storeName: string): void;
    storeExists(storeName: string): boolean;
    getStore(storeName: string): IClientDBUpgraderStore | undefined;
}
export declare type ClientDBQueryOptions<QType extends "single" | "multi"> = {
    type: QType;
} & (QType extends "single" ? {} : {
    count?: number;
});
export interface IClientDBStoreReadOnly<T> {
    query<QType extends "single" | "multi">(key: string | Array<string> | IDBKeyRange, options: ClientDBQueryOptions<QType>): Promise<QType extends "single" ? T : Array<T>>;
    allRecords(): Promise<Array<T>>;
}
export interface IClientDBStoreReadWrite<T> extends IClientDBStoreReadOnly<T> {
    insert(value: T, type: "upsert" | "add or fail", key?: string): Promise<void>;
    delete(key: string | Array<string> | IDBKeyRange): Promise<void>;
}
export interface IClientDBTransactionReadOnlySingle {
    getStore<T>(): IClientDBStoreReadOnly<T>;
}
export interface IClientDBTransactionReadWriteSingle extends IClientDBTransactionReadOnlySingle {
    getStore<T>(): IClientDBStoreReadWrite<T>;
}
export interface IClientDBTransactionReadOnlyMultiple {
    getStore<T>(storeName: string): IClientDBStoreReadOnly<T>;
}
export interface IClientDBTransactionReadWriteMultiple extends IClientDBTransactionReadOnlyMultiple {
    getStore<T>(storeName: string): IClientDBStoreReadWrite<T>;
}
export declare type ClientDBTransactionTypeSingle = {
    readwrite: IClientDBTransactionReadWriteSingle;
    readonly: IClientDBTransactionReadOnlySingle;
};
export declare type ClientDBTransactionTypeMultiple = {
    readwrite: IClientDBTransactionReadWriteMultiple;
    readonly: IClientDBTransactionReadOnlyMultiple;
};
export declare type singleScopeCB<TMode extends keyof ClientDBTransactionTypeSingle, TRetval> = (tx: ClientDBTransactionTypeSingle[TMode]) => TRetval | Promise<TRetval>;
export declare type multiScopeCB<TMode extends keyof ClientDBTransactionTypeMultiple, TRetval> = (tx: ClientDBTransactionTypeMultiple[TMode]) => TRetval | Promise<TRetval>;
export interface IClientDBConnection {
    closeDB(): void;
    scope<TMode extends keyof ClientDBTransactionTypeSingle, TRetval>(storeName: string, mode: TMode, cb: singleScopeCB<TMode, TRetval>): Promise<TRetval>;
    scope<TMode extends keyof ClientDBTransactionTypeMultiple, TRetval>(storeName: Array<string>, mode: TMode, cb: multiScopeCB<TMode, TRetval>): Promise<TRetval>;
}
export declare type IClientDBUpgradeNeededCB = (upgrader: IClientDBUpgrader, version: {
    old: number;
    new: number;
}) => Promise<void> | void;
export interface IClientDBOpenOptions {
    upgradeNeeded: IClientDBUpgradeNeededCB;
}
export interface IClientDBInfo {
    name: string | undefined;
    version: IClientDBVersion | undefined;
}
export interface IClientDB {
    listDatabases(): Promise<Array<IClientDBInfo>>;
    openDB(dbName: string, version: IClientDBVersion, options: IClientDBOpenOptions): Promise<IClientDBConnection>;
    deleteDB(dbName: string): void;
}
export declare const IClientDB: unique symbol;
//# sourceMappingURL=IClientDB.d.ts.map