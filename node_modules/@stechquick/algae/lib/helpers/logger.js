"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.LogType = exports.LogLevelLookup = exports.LogLevel = void 0;
var windowHelper_1 = require("./windowHelper");
var LogLevel;
(function (LogLevel) {
    LogLevel["debug"] = "DEBUG";
    LogLevel["info"] = "INFO";
    LogLevel["log"] = "LOG";
    LogLevel["trace"] = "TRACE";
    LogLevel["warn"] = "WARNING";
    LogLevel["error"] = "ERROR";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
exports.LogLevelLookup = {
    DEBUG: 10,
    INFO: 20,
    LOG: 30,
    TRACE: 40,
    WARNING: 50,
    ERROR: 60,
};
var LogType;
(function (LogType) {
    LogType[LogType["Debug"] = 0] = "Debug";
    LogType[LogType["MobilDebug"] = 1000] = "MobilDebug";
    LogType[LogType["Trace"] = 200000] = "Trace";
    LogType[LogType["Warning"] = 500000] = "Warning";
    LogType[LogType["Error"] = 1000000] = "Error"; // 500Kb
})(LogType = exports.LogType || (exports.LogType = {}));
var Singularizer = /** @class */ (function () {
    function Singularizer() {
    }
    Singularizer.trySingularize = function (name, instance) {
        if (!this.singularized(name)) {
            windowHelper_1.WindowHelper.Instance.Window[name] = instance;
            return true;
        }
        return false;
    };
    Singularizer.singularized = function (name) {
        return windowHelper_1.WindowHelper.Instance.Window[name];
    };
    Singularizer.getFreeName = function (name) {
        var _a;
        var win = (_a = windowHelper_1.WindowHelper === null || windowHelper_1.WindowHelper === void 0 ? void 0 : windowHelper_1.WindowHelper.Instance.Window) !== null && _a !== void 0 ? _a : {};
        var counter = 0;
        while (win[name + "_" + ++counter])
            ;
        return name + "_" + counter;
    };
    return Singularizer;
}());
var Logger = /** @class */ (function () {
    function Logger() {
    }
    /**
    * Console log function
    * @param logMessage Message that to be written to the console
    * @param logType console type(Debug, Trace, Warning, Error)
    * @param backgroundColor message background color
    * @param color message text color
    * @param additional additional info for logging
    * @param yamlLogType
    * @returns void
    */
    Logger.Log = function (_a) {
        var logMessage = _a.logMessage, _b = _a.logType, logType = _b === void 0 ? LogType.Trace : _b, error = _a.error, _c = _a.backgroundColor, backgroundColor = _c === void 0 ? null : _c, _d = _a.textColor, textColor = _d === void 0 ? null : _d, _e = _a.additional, additional = _e === void 0 ? null : _e, source = _a.source, _f = _a.isClientLog, isClientLog = _f === void 0 ? false : _f, yamlLogType = _a.yamlLogType, minEngineLogLevel = _a.minEngineLogLevel;
        var colorOptions = backgroundColor || textColor ? "background: " + backgroundColor + "; color: " + textColor : null;
        var targetLog;
        switch (true) {
            case logType == LogType.MobilDebug && this.logLevel.indexOf(LogType.MobilDebug) > -1:
                targetLog = console.log;
                break;
            case (logType == LogType.Debug && this.logLevel.indexOf(LogType.Debug) > -1):
            case (logType == LogType.Trace && this.logLevel.indexOf(LogType.Trace) > -1):
                targetLog = console.log;
                break;
            case (logType == LogType.Error && this.logLevel.indexOf(LogType.Error) > -1):
                targetLog = console.error;
                break;
            case (logType == LogType.Warning && this.logLevel.indexOf(LogType.Warning) > -1):
                targetLog = console.warn;
                break;
            case true:
                break;
        }
        var params = [logMessage];
        if (colorOptions && typeof logMessage === "string") {
            params[0] = '%c' + logMessage;
            params.push(colorOptions);
        }
        if (error) {
            params.push(error);
        }
        if (additional) {
            params.push(additional);
        }
        if (source) { // MUST BE LAST!!!! (used in mobile sim. -> editor logging)
            params.push({ source: source });
        }
        targetLog === null || targetLog === void 0 ? void 0 : targetLog.apply(console, params);
        if (isClientLog || (isClientLog && yamlLogType && yamlLogType <= logType) || minEngineLogLevel && minEngineLogLevel <= logType) {
            this.prepareClientLog(logMessage, logType);
        }
    };
    /**
    * Log messages are controlled by their size and add them to the bulk array with type, date and caller function name
    * @param logMessage Message that will be written to the server
    * @param logType Type of log message
    */
    Logger.prepareClientLog = function (logMessage, logType) {
        var _a;
        var currentDateFormat = new Date(Date.now());
        var clientDate = currentDateFormat.getFullYear() + "." + ("0" + (currentDateFormat.getMonth() + 1)).slice(-2) + "." + ("0" + currentDateFormat.getDate()).slice(-2) + " " +
            currentDateFormat.getHours() + ':' + ("0" + currentDateFormat.getMinutes()).slice(-2) + ':' + ("0" + currentDateFormat.getSeconds()).slice(-2) + ':' + currentDateFormat.getMilliseconds();
        ;
        var message;
        var whoCallMe = this.getCalleFunctionName();
        if (typeof logMessage !== "string" && logType > 0) {
            try {
                message = this.shorten(JSON.stringify(logMessage), logType);
            }
            catch (error) {
                message = "Can not stringfy the given log. Type of log data is: " + Object.prototype.toString.call(logMessage);
            }
        }
        else {
            message = this.shorten(logMessage, logType);
        }
        (_a = Logger.LogBulkManager) === null || _a === void 0 ? void 0 : _a.writeMessage({ message: message, type: LogType[logType], time: clientDate, caller: whoCallMe });
    };
    /**
 * Can't call Log.calle.caller beacuse of the TypeScript classes are on "strict mode"
 * JS doesn't allow to arguments.callee.caller on strict mode
 * So just throw an simple Error and get the latest function name
 * returns String
 */
    Logger.getCalleFunctionName = function () {
        // try {
        //     throw new Error();
        // }
        // catch (e) {
        //     try {
        //         return e.stack.split('at ')[4].split(' ')[0];
        //     } catch (e) {
        //         return '';
        //     }
        // }
        return '';
    };
    /**
     * Trim the message with size of the log type
     * @param logMessage log message
     * @param logType Log type that will be controlled
     */
    Logger.shorten = function (logMessage, logType) {
        if (logType > logMessage.length) {
            return logMessage;
        }
        else {
            return "Non trimmed message size is: " + logMessage.length;
        }
    };
    ;
    Object.defineProperty(Logger, "LogBulkManager", {
        get: function () {
            if (!Logger.logBulkManager) {
                Logger.logBulkManager = Singularizer.singularized(Logger.windowName);
            }
            return Logger.logBulkManager;
        },
        enumerable: false,
        configurable: true
    });
    Logger.log = function (logItem) {
        var params = [];
        if (logItem.timeFormat) {
            params.push(this.getDatetimeString(logItem.timeFormat));
        }
        params.push(logItem.message);
        if (logItem.error) {
            params.push(logItem.error);
        }
        if (logItem.additional) {
            params.push(logItem.additional);
        }
        var targetLog = this.getTargetLog(logItem.level);
        targetLog.apply(console, params);
    };
    Logger.getDatetimeString = function (format) {
        var date = new Date();
        switch (format) {
            case "date":
                return date.toLocaleDateString('tr-TR');
            case "datepath":
                return "" + date.toISOString().slice(0, 10);
            case "time":
                return date.toLocaleTimeString('tr-TR') + "." + date.getMilliseconds();
            case "datetime":
                return date.toLocaleString('tr-TR') + "." + date.getMilliseconds();
        }
    };
    Logger.getTargetLog = function (logLevel) {
        var targetLog;
        switch (logLevel) {
            case LogLevel.debug:
                targetLog = console.debug;
                break;
            case LogLevel.info:
                targetLog = console.info;
                break;
            case LogLevel.log:
                targetLog = console.log;
                break;
            case LogLevel.trace:
                targetLog = console.trace;
                break;
            case LogLevel.warn:
                targetLog = console.warn;
                break;
            case LogLevel.error:
                targetLog = console.error;
                break;
            default:
                targetLog = console.log;
        }
        return targetLog;
    };
    Logger.logLevel = [LogType.MobilDebug, LogType.Trace, LogType.Debug, LogType.Warning, LogType.Error];
    Logger.windowName = Singularizer.getFreeName("shrimp_shelldorynemo_pulsar_lbm");
    return Logger;
}());
exports.Logger = Logger;
//# sourceMappingURL=logger.js.map