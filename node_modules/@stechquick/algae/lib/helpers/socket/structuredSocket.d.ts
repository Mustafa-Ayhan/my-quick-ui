/// <reference types="node" />
import { DefaultTransferBuffer, ISocket } from "./iSocket";
interface ISocketMessage {
    type: string;
    [key: string]: any;
}
export interface ISocketPackage<K> {
    id: string;
    replyId?: string;
    msg: K;
}
export interface IStructedSendOptions<TTransferBuffer = DefaultTransferBuffer> {
    replyId?: string;
    awaitResponse?: boolean;
    awaitTime?: number;
    transferBuffers?: Array<TTransferBuffer>;
}
export declare type StructuredMessageTypeDict = Record<string, ISocketMessage>;
export declare class StructuredSocket<MessageType extends StructuredMessageTypeDict, TTransferBuffer = DefaultTransferBuffer> {
    private socket;
    private awaitMsgList;
    private eventBus;
    constructor(socket: ISocket<TTransferBuffer>);
    CreatePackage<K extends keyof MessageType>(msg: MessageType[K], options: {
        replyId?: string;
        awaitResponse?: boolean;
        awaitTime?: number;
    }): ISocketPackage<MessageType[K]>;
    Send<K extends keyof MessageType>(msg: MessageType[K], options: IStructedSendOptions<TTransferBuffer>): Promise<ISocketPackage<MessageType[keyof MessageType]>> | undefined;
    Subscribe<K extends keyof MessageType>(key: K, cb: (data: ISocketPackage<MessageType[K]>) => (void | Promise<void>)): void;
    Unsubscribe<K extends keyof MessageType>(key: K, cb: (data: ISocketPackage<MessageType[K]>) => (void | Promise<void>)): void;
    SubscribeAll(cb: (data: ISocketPackage<MessageType[keyof MessageType]>) => (void | Promise<void>)): void;
    UnsubscribeAll(cb: (data: ISocketPackage<MessageType[keyof MessageType]>) => (void | Promise<void>)): void;
    private tryLogJsonParseEx;
    ConvertBufferToStructure(data: string | Buffer | ArrayBuffer | Buffer[] | object): ISocketPackage<MessageType[keyof MessageType]> | undefined;
    private listen;
    destroy(reason?: string): void;
}
export {};
//# sourceMappingURL=structuredSocket.d.ts.map