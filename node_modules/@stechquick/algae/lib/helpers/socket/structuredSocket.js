"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructuredSocket = void 0;
var createPromiseData_1 = require("../createPromiseData");
var cryptoHelper_1 = require("../cryptoHelper");
var eventBus_1 = require("../eventBus");
;
var StructuredSocket = /** @class */ (function () {
    function StructuredSocket(socket) {
        this.socket = socket;
        this.awaitMsgList = {};
        this.eventBus = new eventBus_1.EventBus();
        socket.OnMessage = this.listen.bind(this);
    }
    StructuredSocket.prototype.CreatePackage = function (msg, options) {
        var packet = { msg: msg, id: cryptoHelper_1.CryptoHelper.CreateGuid(), replyId: options.replyId };
        return packet;
    };
    StructuredSocket.prototype.Send = function (msg, options) {
        var packet = this.CreatePackage(msg, options);
        this.socket.Send(packet, { transferBuffers: options.transferBuffers });
        if (!options.awaitResponse) {
            return undefined;
        }
        var promData = (0, createPromiseData_1.CreatePromiseData)(options.awaitTime);
        this.awaitMsgList[packet.id] = { promData: promData };
        return promData.promise;
    };
    StructuredSocket.prototype.Subscribe = function (key, cb) {
        this.eventBus.Subscribe(key, cb);
    };
    StructuredSocket.prototype.Unsubscribe = function (key, cb) {
        this.eventBus.Unsubscribe(key, cb);
    };
    StructuredSocket.prototype.SubscribeAll = function (cb) {
        this.eventBus.SubscribeAll(cb);
    };
    StructuredSocket.prototype.UnsubscribeAll = function (cb) {
        this.eventBus.UnsubscribeAll(cb);
    };
    StructuredSocket.prototype.tryLogJsonParseEx = function (str) {
        try {
            return JSON.parse(str);
        }
        catch (ex) {
            var err = ex;
            if (!err.message) {
                throw ex;
            }
            var jsonPosInfo = "in JSON at position";
            var index = err.message.indexOf(jsonPosInfo);
            if (index <= -1) {
                throw ex;
            }
            var posInfo = err.message.substring(index + jsonPosInfo.length);
            var pos = Number(posInfo);
            if (isNaN(pos)) {
                throw ex;
            }
            var start = pos < 30 ? 0 : pos - 30;
            var end = pos > str.length - 30 ? str.length : pos + 30;
            var log = str.substring(start, end);
            console.log(log + "\n" + " ".repeat(pos - start) + "^");
            throw ex;
        }
    };
    StructuredSocket.prototype.ConvertBufferToStructure = function (data) {
        try {
            var packet = (this.socket.OnMessageWithDirectObject ? data : this.tryLogJsonParseEx(data.toString()));
            if (!packet) {
                console.log("unexpected message format: undefined");
                return undefined;
            }
            if (!packet.msg || !packet.msg.type) {
                console.log("unexpected message format: missing {msg:{type: ... }} structure");
                return undefined;
            }
            return packet;
        }
        catch (ex) {
            console.log("unexpected message format: json.parse error: ", ex);
            return undefined;
        }
    };
    StructuredSocket.prototype.listen = function (data) {
        var packet = this.ConvertBufferToStructure(data);
        if (!packet) {
            return undefined;
        }
        if (packet.replyId) {
            var awaiter = this.awaitMsgList[packet.replyId];
            if (awaiter) {
                delete this.awaitMsgList[packet.replyId];
                awaiter.promData.resolver(packet);
            }
            this.eventBus.TriggerJustAllSubs(packet);
            return;
        }
        this.eventBus.Trigger(packet.msg.type, packet);
    };
    StructuredSocket.prototype.destroy = function (reason) {
        this.socket.destroy();
        var awaitMsgList = this.awaitMsgList;
        this.awaitMsgList = {};
        this.eventBus.destroy();
        var errorForWaiters = new Error(reason || "structuredSocket destroyed with no reason specified");
        Object.keys(awaitMsgList).forEach(function (key) { var _a; return (_a = awaitMsgList[key]) === null || _a === void 0 ? void 0 : _a.promData.reject(errorForWaiters); });
    };
    return StructuredSocket;
}());
exports.StructuredSocket = StructuredSocket;
//# sourceMappingURL=structuredSocket.js.map