{"version":3,"file":"structuredSocket.js","sourceRoot":"","sources":["../../../src/helpers/socket/structuredSocket.ts"],"names":[],"mappings":"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","sourcesContent":["import { CreatePromiseData, IPromiseData } from \"../createPromiseData\";\nimport { CryptoHelper } from \"../cryptoHelper\";\nimport { EventBus } from \"../eventBus\";\nimport { DefaultTransferBuffer, ISocket } from \"./iSocket\";\n\n\n\n\n\ninterface ISocketMessage {\n    type: string;\n    [key: string]: any;\n}\nexport interface ISocketPackage<K> {\n    id: string;\n    replyId?: string;\n    msg: K;\n}\n\nexport interface IStructedSendOptions<TTransferBuffer = DefaultTransferBuffer> {\n    replyId?: string;\n    awaitResponse?: boolean;\n    awaitTime?: number;\n    transferBuffers?: Array<TTransferBuffer>;\n};\n\nexport type StructuredMessageTypeDict = Record<string, ISocketMessage>;\n\nexport class StructuredSocket<MessageType extends StructuredMessageTypeDict, TTransferBuffer = DefaultTransferBuffer> {\n    private socket: ISocket<TTransferBuffer>;\n    private awaitMsgList: Record<string, { promData: IPromiseData<ISocketPackage<MessageType[keyof MessageType]>> } | undefined>;\n    private eventBus: EventBus;\n    constructor(socket: ISocket<TTransferBuffer>) {\n        this.socket = socket;\n        this.awaitMsgList = {};\n        this.eventBus = new EventBus();\n        socket.OnMessage = this.listen.bind(this);\n    }\n\n    public CreatePackage<K extends keyof MessageType>(msg: MessageType[K], options: { replyId?: string, awaitResponse?: boolean, awaitTime?: number }) {\n        const packet: ISocketPackage<MessageType[K]> = { msg, id: CryptoHelper.CreateGuid(), replyId: options.replyId };\n        return packet;\n    }\n\n    public Send<K extends keyof MessageType>(msg: MessageType[K], options: IStructedSendOptions<TTransferBuffer>) {\n        const packet = this.CreatePackage(msg, options);\n        this.socket.Send(packet, { transferBuffers: options.transferBuffers });\n        if (!options.awaitResponse) { return undefined; }\n\n        const promData = CreatePromiseData<ISocketPackage<MessageType[keyof MessageType]>>(options.awaitTime);\n        this.awaitMsgList[packet.id] = { promData };\n        return promData.promise;\n    }\n\n    public Subscribe<K extends keyof MessageType>(key: K, cb: (data: ISocketPackage<MessageType[K]>) => (void | Promise<void>)) {\n        this.eventBus.Subscribe(key as string, cb);\n    }\n\n    public Unsubscribe<K extends keyof MessageType>(key: K, cb: (data: ISocketPackage<MessageType[K]>) => (void | Promise<void>)){\n        this.eventBus.Unsubscribe(key as string, cb);\n    }\n\n    public SubscribeAll(cb: (data: ISocketPackage<MessageType[keyof MessageType]>) => (void | Promise<void>)){\n        this.eventBus.SubscribeAll(cb);\n    }\n    public UnsubscribeAll(cb: (data: ISocketPackage<MessageType[keyof MessageType]>) => (void | Promise<void>)){\n        this.eventBus.UnsubscribeAll(cb);\n    }\n\n    private tryLogJsonParseEx(str: string) {\n        try {\n            return JSON.parse(str);\n        } catch (ex) {\n            const err = ex as { message?: string };\n            if (!err.message) { throw ex; }\n            const jsonPosInfo = \"in JSON at position\";\n            const index = err.message.indexOf(jsonPosInfo);\n            if (index <= -1) { throw ex; }\n            const posInfo = err.message.substring(index + jsonPosInfo.length);\n            const pos = Number(posInfo);\n            if (isNaN(pos)) { throw ex; }\n            const start = pos < 30 ? 0 : pos - 30;\n            const end = pos > str.length - 30 ? str.length : pos + 30;\n            const log = str.substring(start, end);\n            console.log(log + \"\\n\" + \" \".repeat(pos - start) + \"^\");\n            throw ex;\n        }\n    }\n\n    public ConvertBufferToStructure(data: string | Buffer | ArrayBuffer | Buffer[] | object) {\n        try {\n            const packet = (this.socket.OnMessageWithDirectObject ? data : this.tryLogJsonParseEx(data.toString())) as ISocketPackage<MessageType[keyof MessageType]> | undefined;\n            if (!packet) { console.log(\"unexpected message format: undefined\"); return undefined; }\n            if (!packet.msg || !packet.msg.type) { console.log(\"unexpected message format: missing {msg:{type: ... }} structure\"); return undefined; }\n            return packet;\n        } catch (ex) {\n            console.log(\"unexpected message format: json.parse error: \", ex);\n            return undefined;\n        }\n    }\n\n    private listen(data: string | Buffer | ArrayBuffer | Buffer[] | object) {\n        let packet = this.ConvertBufferToStructure(data);\n        if (!packet) { return undefined; }\n\n        if (packet.replyId) {\n            const awaiter = this.awaitMsgList[packet.replyId];\n            if (awaiter) {\n                delete this.awaitMsgList[packet.replyId];\n                awaiter.promData.resolver(packet);\n            }\n            this.eventBus.TriggerJustAllSubs(packet);\n            return;\n        }\n\n        this.eventBus.Trigger(packet.msg.type, packet);\n    }\n\n    public destroy(reason?: string) {\n        this.socket.destroy();\n        const awaitMsgList = this.awaitMsgList;\n        this.awaitMsgList = {};\n        this.eventBus.destroy();\n        const errorForWaiters = new Error(reason || `structuredSocket destroyed with no reason specified`);\n        Object.keys(awaitMsgList).forEach(key => awaitMsgList[key]?.promData.reject(errorForWaiters));\n    }\n}"]}