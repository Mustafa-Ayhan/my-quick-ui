{"version":3,"file":"fileHelper.js","sourceRoot":"","sources":["../../src/helpers/fileHelper.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qCAAyB;AACzB,yCAA6B;AAE7B,yBAA8B;AAC9B,IAAM,UAAU,GAAG,aAAQ,CAAC;AAE5B,SAAS,mBAAmB,CAAC,MAAc,EAAE,QAA8F,EAAE,iBAAqF;IAC9N,SAAS,0BAA0B,CAAC,MAAc,EAAE,WAAmB;QACnE,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,UAAA,IAAI;YAC/B,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAC5C,IAAM,WAAW,GAAG,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC;YAE3D,IAAI,WAAW,EAAE;gBACb,IAAI,CAAC,iBAAiB,KAAI,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAG,MAAM,EAAE,IAAI,EAAE,WAAW,CAAC,CAAA,EAAE;oBACtE,0BAA0B,CAAC,WAAW,EAAE,WAAW,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;oBAClE,QAAQ,CAAC,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;iBAC7C;aACJ;iBAAM;gBACH,QAAQ,CAAC,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;aAC9C;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IACD,0BAA0B,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;AAC3C,CAAC;AAAA,CAAC;AAGF;;;;;GAKG;AACH,SAAgB,UAAU,CAAC,MAAc,EAAE,WAAmB,EAAE,MAAsB,EAAE,WAAgJ;IACpO,IAAM,UAAU,GAAG,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,EAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAA0B,UAAC,IAAI,EAAE,OAAO,IAAO,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACtJ,mBAAmB,CAAC,MAAM,EACtB,UAAC,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,WAAW;QACtC,IAAI,WAAW,EAAE;YAAE,OAAO;SAAE;QAC5B,IAAI,UAAU,EAAE;YACZ,IAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;YACzD,IAAI,UAAU,CAAC,gBAAgB,CAAC,EAAE;gBAC9B,OAAO;aACV;SACJ;QACD,IAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;QACtD,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC,CAAC;QACtE,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YAC1B,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;SAC/C;QACD,IAAI,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,sBAAsB,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE;YAClE,IAAI,mBAAmB,GAAG,WAAW,CAAC,eAAe,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;YAC5F,IAAI,mBAAmB,CAAC,OAAO,EAAE;gBAC7B,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,mBAAmB,CAAC,KAAK,CAAC,CAAC;aAC1E;SACJ;aACI;YACD,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;SACvD;IACL,CAAC,EACD,UAAC,MAAM,EAAE,IAAI,EAAE,cAAc;QACzB,IAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;QACzD,IAAI,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAG,gBAAgB,CAAC,EAAE;YAChC,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC;IAChB,CAAC,CACJ,CAAC;AACN,CAAC;AAlCD,gCAkCC;AACD;;;;;;GAMG;AACH,SAAgB,QAAQ,CAAC,MAAc,EAAE,WAAmB,EAAE,OAA8E;IAA9E,wBAAA,EAAA,YAA6D,SAAS,EAAE,IAAI,EAAE;IACxI,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACtC,IAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACrC,IAAI,OAAO,CAAC,YAAY,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QACjD,OAAO;KACV;IAED,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IAC3C,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QAC1B,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC;KAC5D;IACD,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,IAAI,CAAC,CAAA;IACrD,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACvC,CAAC;AAbD,4BAaC;AAED;;;;GAIG;AACH,SAAgB,YAAY,CAAC,MAAc;IACvC,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;QACxB,OAAO;KACV;IACD,mBAAmB,CAAC,MAAM,EAAE,UAAC,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,WAAW;QAClE,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QACxC,IAAI,WAAW,EAAE;YACb,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;SACzB;aAAM;YACH,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;SAC1C;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAZD,oCAYC;AAED,SAAsB,SAAS,CAAC,SAAiB,EAAE,UAAkB,EAAE,WAAoC;;;;YACvG,sBAAO,IAAI,OAAO,CAAC,UAAO,OAAO,EAAE,MAAM;;;;;;gCAG3B,MAAM,GAAG,EAAE,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;gCAC/B,sFAAa,UAAU,QAAC;;gCAAnC,QAAQ,GAAG,SAAwB;gCACnC,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAC;gCACvB,OAAO,GAAG,GAAG,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;gCAEnD,4CAA4C;gCAC5C,iEAAiE;gCACjE,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE;oCACf,OAAO,CAAC,UAAU,CAAC,CAAC;gCACxB,CAAC,CAAC,CAAC;gCAEH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,UAAU,GAAQ;oCACjC,MAAM,GAAG,CAAC;gCACd,CAAC,CAAC,CAAC;gCAEH,+CAA+C;gCAC/C,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,UAAU,GAAQ;oCAClC,MAAM,GAAG,CAAC;gCACd,CAAC,CAAC,CAAC;gCAEH,gCAAgC;gCAChC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gCACrB,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;gCACpC,OAAO,CAAC,QAAQ,EAAE,CAAC;;;;gCAGnB,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAG,OAAK,CAAC,CAAC;gCACrB,MAAM,CAAC,OAAK,CAAC,CAAC;;;;;qBAErB,CAAC,EAAC;;;CACN;AAlCD,8BAkCC;AAED,SAAsB,cAAc,CAAC,QAAgB,EAAE,WAAoC;;;;;;;oBAG1E,qBAAM,UAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAG,OAA0B,EAAE,CAAC,EAAA;;oBAAvF,MAAM,GAAG,SAA8E,CAAC;;;;oBAC5E,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAG,KAAG,CAAC,CAAC;;wBACnC,sBAAO,MAAM,EAAC;;;;CACjB;AAND,wCAMC;AAGD,SAAsB,QAAQ,CAAC,QAAgB;;;YAC3C,sBAAO,IAAI,OAAO,CAAS,UAAC,GAAG,EAAE,GAAG;oBAChC,EAAE,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,UAAC,GAAG,EAAE,IAAI;wBACnD,IAAI,GAAG,EAAE;4BAAE,GAAG,CAAC,GAAG,CAAC,CAAC;4BAAC,OAAO;yBAAE;wBAC9B,GAAG,CAAC,IAAI,CAAC,CAAC;oBACd,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,EAAC;;;CACN;AAPD,4BAOC;AACD,SAAgB,aAAa,CAAC,UAAkB;IAAhD,iBAOC;IANG,OAAO,IAAI,OAAO,CAAO,UAAO,GAAG,EAAE,GAAG;;YACpC,EAAE,CAAC,KAAK,CAAC,UAAU,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,EAAE,UAAC,GAAG;gBAC1C,IAAI,GAAG,EAAE;oBAAE,GAAG,CAAC,GAAG,CAAC,CAAC;oBAAC,OAAO;iBAAE;gBAC9B,GAAG,EAAE,CAAC;YACV,CAAC,CAAC,CAAC;;;SACN,CAAC,CAAC;AACP,CAAC;AAPD,sCAOC;AACD,SAAsB,SAAS,CAAC,QAAgB,EAAE,KAAsC,EAAE,EAAqJ;QAArJ,qBAAmJ,EAAE,KAAA,EAAnJ,gBAAkB,EAAlB,QAAQ,mBAAG,OAAO,KAAA,EAAE,IAAI,UAAA,EAAiB,mBAAmB,mBAAA;;;;YACpJ,sBAAO,IAAI,OAAO,CAAO,UAAO,GAAG,EAAE,GAAG;;;;;qCAChC,mBAAmB,EAAnB,wBAAmB;gCACb,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC;gCACxC,qBAAM,aAAa,CAAC,MAAM,CAAC,EAAA;;gCAA3B,SAA2B,CAAC;;;gCAEhC,EAAE,CAAC,SAAS,CAAC,QAAQ,EAAE,KAAK,EAAE,EAAE,QAAQ,UAAA,EAAE,IAAI,MAAA,EAAE,EAAE,UAAA,GAAG;oCACjD,IAAI,GAAG,EAAE;wCAAE,GAAG,CAAC,GAAG,CAAC,CAAC;wCAAC,OAAO;qCAAE;oCAC9B,GAAG,EAAE,CAAC;gCACV,CAAC,CAAC,CAAC;;;;qBACN,CAAC,EAAC;;;CACN;AAXD,8BAWC;AACD,SAAsB,OAAO,CAAC,UAAkB;;;YAC5C,sBAAO,IAAI,OAAO,CAAgB,UAAC,GAAG,EAAE,GAAG;oBACvC,EAAE,CAAC,OAAO,CAAC,UAAU,EAAE,UAAC,GAAG,EAAE,KAAK;wBAC9B,IAAI,GAAG,EAAE;4BAAE,GAAG,CAAC,GAAG,CAAC,CAAC;4BAAC,OAAO;yBAAE;wBAC9B,GAAG,CAAC,KAAK,CAAC,CAAC;oBACf,CAAC,CAAC,CAAA;gBACN,CAAC,CAAC,EAAC;;;CACN;AAPD,0BAOC;AAAA,CAAC;AACF,SAAsB,KAAK,CAAC,QAAgB;;;YACxC,sBAAO,IAAI,OAAO,CAAW,UAAC,GAAG,EAAE,GAAG;oBAClC,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAC,GAAG,EAAE,KAAK;wBACzB,IAAI,GAAG,EAAE;4BAAE,GAAG,CAAC,GAAG,CAAC,CAAC;4BAAC,OAAO;yBAAE;wBAC9B,GAAG,CAAC,KAAK,CAAC,CAAC;oBACf,CAAC,CAAC,CAAA;gBACN,CAAC,CAAC,EAAC;;;CACN;AAPD,sBAOC;AAAA,CAAC;AACF,SAAsB,MAAM,CAAC,QAAgB;;;;;;;oBAErC,qBAAM,KAAK,CAAC,QAAQ,CAAC,EAAA;;oBAArB,SAAqB,CAAC;oBACtB,sBAAO,IAAI,EAAC;;;oBAEZ,IAAK,KAA6B,CAAC,IAAI,KAAK,QAAQ,EAAE;wBAClD,sBAAO,KAAK,EAAC;qBAChB;oBAAA,CAAC;oBACF,MAAM,KAAG,CAAC;;;;;CAEjB;AAVD,wBAUC","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport { promises } from \"fs\";\nconst fsPromises = promises;\n\nfunction ForEachItemInFolder(folder: string, iterator: (folder: string, item: string, relativeFolder: string, isDirectory: boolean) => void, willIterateFolder?: (folder: string, item: string, relativeFolder: string) => boolean) {\n    function forEachItemInFoderInternal(folder: string, curRelative: string) {\n        fs.readdirSync(folder).forEach(item => {\n            const curItemPath = path.join(folder, item);\n            const isDirectory = fs.statSync(curItemPath).isDirectory();\n\n            if (isDirectory) {\n                if (!willIterateFolder || willIterateFolder?.(folder, item, curRelative)) {\n                    forEachItemInFoderInternal(curItemPath, curRelative + \"/\" + item);\n                    iterator(folder, item, curRelative, true);\n                }\n            } else {\n                iterator(folder, item, curRelative, false);\n            }\n        });\n    }\n    forEachItemInFoderInternal(folder, \"\");\n};\n\n\n/**\n * copies folder from source to destination. if except param is given, excepts folders or files.\n * @param source \n * @param destination \n * @param except \n */\nexport function CopyFolder(source: string, destination: string, except?: Array<string>, distinction?: { distinctFileExtensions: Array<string>, distinctFilesCb: (source: string) => { value: string, success: boolean }, context?: any }) {\n    const exceptDict = except?.length ? except.reduce<Record<string, boolean>>((prev, current) => { prev[current] = true; return prev; }, {}) : undefined;\n    ForEachItemInFolder(source,\n        (folder, item, relativeFolder, isDirectory) => {\n            if (isDirectory) { return; }\n            if (exceptDict) {\n                const relativeItemPath = path.join(relativeFolder, item);\n                if (exceptDict[relativeItemPath]) {\n                    return;\n                }\n            }\n            const srcPath = path.resolve(path.join(folder, item));\n            const destPath = path.resolve(path.join(destination, relativeFolder));\n            if (!fs.existsSync(destPath)) {\n                fs.mkdirSync(destPath, { recursive: true });\n            }\n            if (distinction?.distinctFileExtensions.includes(path.extname(item))) {\n                var modifiedFileContent = distinction.distinctFilesCb.apply(distinction.context, [srcPath]);\n                if (modifiedFileContent.success) {\n                    fs.writeFileSync(path.join(destPath, item), modifiedFileContent.value);\n                }\n            }\n            else {\n                fs.copyFileSync(srcPath, path.join(destPath, item));\n            }\n        },\n        (folder, item, relativeFolder) => {\n            const relativeItemPath = path.join(relativeFolder, item);\n            if (exceptDict?.[relativeItemPath]) {\n                return false;\n            }\n            return true;\n        }\n    );\n}\n/**\n * copies file source to destination\n * @param source \n * @param destination \n * @param options \n * @returns \n */\nexport function CopyFile(source: string, destination: string, options: { copyIfExists?: boolean, recursive?: boolean } = { recursive: true }) {\n    const pathParsed = path.parse(source);\n    const srcFile = path.resolve(source);\n    if (options.copyIfExists && !fs.existsSync(srcFile)) {\n        return;\n    }\n\n    const destPath = path.resolve(destination);\n    if (!fs.existsSync(destPath)) {\n        fs.mkdirSync(destPath, { recursive: options.recursive });\n    }\n    const destFile = path.join(destPath, pathParsed.base)\n    fs.copyFileSync(srcFile, destFile);\n}\n\n/**\n * deletes folder recursively\n * @param target \n * @returns \n */\nexport function DeleteFolder(target: string) {\n    if (!fs.existsSync(target)) {\n        return;\n    }\n    ForEachItemInFolder(target, (folder, item, relativeFolder, isDirectory) => {\n        const curPath = path.join(folder, item);\n        if (isDirectory) {\n            fs.rmdirSync(curPath);\n        } else {\n            fs.unlinkSync(path.join(folder, item));\n        }\n    });\n}\n\nexport async function zipFolder(directory: string, outputFile: string, errCallback?: (err: unknown) => void): Promise<string> {\n    return new Promise(async (resolve, reject) => {\n        try {\n            // create a file to stream archive data to.\n            const output = fs.createWriteStream(outputFile);\n            const archiver = await import(\"archiver\");\n            const zip = archiver.default;\n            const archive = zip('zip', { zlib: { level: 9 } });\n\n            // listen for all archive data to be written\n            // 'close' event is fired only when a file descriptor is involved\n            output.on('close', function () {\n                resolve(outputFile);\n            });\n\n            output.on('error', function (err: any) {\n                throw err;\n            });\n\n            // good practice to catch this error explicitly\n            archive.on('error', function (err: any) {\n                throw err;\n            });\n\n            // pipe archive data to the file\n            archive.pipe(output);\n            archive.directory(directory, false);\n            archive.finalize();\n\n        } catch (error) {\n            errCallback?.(error);\n            reject(error);\n        }\n    });\n}\n\nexport async function tryGetContents(filePath: string, errCallback?: (err: unknown) => void) {\n    let retVal: string | undefined;\n    try {\n        retVal = await fsPromises.readFile(filePath, { encoding: (\"utf-8\" as BufferEncoding) });\n    } catch (err) { errCallback?.(err); }\n    return retVal;\n}\n\n\nexport async function readFile(fileName: string) {\n    return new Promise<string>((res, rej) => {\n        fs.readFile(fileName, { encoding: \"utf-8\" }, (err, data) => {\n            if (err) { rej(err); return; }\n            res(data);\n        });\n    });\n}\nexport function createFolders(folderPath: string) {\n    return new Promise<void>(async (res, rej) => {\n        fs.mkdir(folderPath, { recursive: true }, (err) => {\n            if (err) { rej(err); return; }\n            res();\n        });\n    });\n}\nexport async function writeFile(fileName: string, value: string | NodeJS.ArrayBufferView, { encoding = \"utf-8\", mode, createFolders: createFolders_param }: { encoding?: BufferEncoding, mode?: string | number, createFolders?: boolean } = {}) {\n    return new Promise<void>(async (res, rej) => {\n        if (createFolders_param) {\n            const folder = path.parse(fileName).dir;\n            await createFolders(folder);\n        }\n        fs.writeFile(fileName, value, { encoding, mode }, err => {\n            if (err) { rej(err); return; }\n            res();\n        });\n    });\n}\nexport async function readDir(folderPath: string) {\n    return new Promise<Array<string>>((res, rej) => {\n        fs.readdir(folderPath, (err, files) => {\n            if (err) { rej(err); return; }\n            res(files);\n        })\n    });\n};\nexport async function stats(itemPath: string) {\n    return new Promise<fs.Stats>((res, rej) => {\n        fs.stat(itemPath, (err, stats) => {\n            if (err) { rej(err); return; }\n            res(stats);\n        })\n    });\n};\nexport async function exists(itemPath: string) {\n    try {\n        await stats(itemPath);\n        return true;\n    } catch (err) {\n        if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n            return false;\n        };\n        throw err;\n    }\n}"]}