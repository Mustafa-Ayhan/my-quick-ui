{"version":3,"file":"tsCompiler.js","sourceRoot":"","sources":["../../../src/helpers/tsCompiler/tsCompiler.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n///<reference path=\"./cdn/js/typescript/shims/typescriptServices.d.ts\" />\nexport interface ICompileFile { name: string, body: string };\nexport interface ICompiledFile extends ICompileFile {\n    outputText?: string,\n    sourceMapText?: string,\n    diagnostic?: Array<string>\n};\ntype tsExt = {\n    normalizePath(path: string): string;\n    fileExtensionIs(path: string, extension: string): boolean;\n    getNewLineCharacter(options: ts.CompilerOptions, getNewLine?: boolean): string;\n};\ninterface IFolder<T> extends Record<string, T | IFolder<T>> {}\n\nconst extTs = <T>(tsInst: typeof ts): tsExt => <tsExt><unknown>tsInst;\n\nconst Compile = (files: Array<ICompileFile>, options: ts.CompilerOptions): Record<string, ICompiledFile> => {\n    const putFileToFolder = <T>(rootFolder: IFolder<T>, path:string, file: T) => {\n        let folders = path.split(\"/\");\n        const fileName = folders.splice(folders.length - 1)[0];\n        const lastFolder = folders.reduce((prev, cur) => (<IFolder<T>>prev[cur]) = {}, rootFolder);\n        lastFolder[fileName] = file;\n    };\n    const compiledFiles = files.reduce<Record<string, ICompiledFile>>((prev, cur) => { putFileToFolder(prev, cur.name, { name: cur.name, body: cur.body }); return prev; }, {});\n    const fileNames: string[] = files.map(file => file.name);\n    const fileSources: Record<string, ts.SourceFile> = {};\n    const ext = extTs(ts);\n\n    files.forEach(cur => {\n        fileSources[ext.normalizePath(cur.name)] = ts.createSourceFile(cur.name, cur.body, ts.ScriptTarget.ES5); \n    });\n\n    const newLine = ext.getNewLineCharacter(options);\n\n    const compilerHost: ts.CompilerHost = {\n        getSourceFile: function (fileName) { return fileSources[fileName]; },\n        writeFile: function (name: string, text: string) {\n            const extIndex = name.indexOf(\".js\");\n            const fileNameWithExt = name.substring(0, extIndex);\n            const tsName = fileNameWithExt.endsWith('.ts') ? fileNameWithExt : fileNameWithExt + \".ts\";\n            if (ext.fileExtensionIs(name, \".map\")) {\n                compiledFiles[tsName].sourceMapText = text;\n            } else {\n                compiledFiles[tsName].outputText = text;\n            }\n        },\n        getDefaultLibFileName: function () { return \"lib.d.ts\"; },\n        useCaseSensitiveFileNames: function () { return false; },\n        getCanonicalFileName: function (fileName) { return fileName; },\n        getCurrentDirectory: function () { return \"\"; },\n        getNewLine: function () { return newLine; },\n        fileExists: function (fileName: any) { return files[fileName] != undefined; },\n        readFile: function () { return \"\"; },\n        directoryExists: function (dir) { return dir.indexOf(\"type\") <= -1; },\n        getDirectories: function () { return []; }\n    };\n\n    options.noLib = true;\n    options.inlineSourceMap = false;\n\n    let program = ts.createProgram(fileNames, options, compilerHost); \n    let emitResult = program.emit();\n\n    let allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics); \n\n    allDiagnostics.forEach(diagnostic => {\n        if (diagnostic.file) {\n            let { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);\n            let message = ts.flattenDiagnosticMessageText(diagnostic.messageText, \"\\n\"); \n            let curCompiledFile = compiledFiles[diagnostic.file.fileName] || {}; \n            curCompiledFile.diagnostic = curCompiledFile.diagnostic || [];\n            curCompiledFile.diagnostic.push(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);\n        } \n    });\n\n    return compiledFiles;\n};\n\nexport default Compile;\n"]}