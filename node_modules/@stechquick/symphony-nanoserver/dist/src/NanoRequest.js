"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NanoRequest = void 0;
var url_1 = __importDefault(require("url"));
var querystring_1 = __importDefault(require("querystring"));
var httpHelper_1 = require("./helpers/httpHelper");
var NanoRequest = /** @class */ (function () {
    function NanoRequest(httpRequest, routeDict) {
        this.httpRequest = httpRequest;
        this.routeDict = routeDict;
        this.queryStringDict = this.GetQueryString();
    }
    NanoRequest.prototype.GetBody = function () {
        var _this = this;
        var multiPart = httpHelper_1.IsMultiPart(this.httpRequest.headers["content-type"]);
        return new Promise(function (res, rej) {
            var onData;
            var free = function () { _this.httpRequest.removeListener("data", onData); };
            var resW = function (value) { free(); res(value); };
            var rejW = function (reason) { free(); rej(reason); };
            var chunkBuffer = [];
            _this.httpRequest.on("data", onData = function (chunk) {
                chunkBuffer.push(chunk);
            });
            _this.httpRequest.once("close", function () { return rejW(new Error("socket closed prematurely")); }); // if end resolved, this doesn't reject promise
            _this.httpRequest.once("error", function (err) { return rejW(err); });
            _this.httpRequest.once("end", function () {
                var finalChunk = Buffer.concat(chunkBuffer);
                if (multiPart) {
                    resW(finalChunk);
                    return;
                }
                var json = finalChunk.toString();
                try {
                    json = JSON.parse(json);
                }
                catch (_a) { }
                resW(json);
            });
        });
    };
    NanoRequest.prototype.getBodyRaw = function () {
        var _this = this;
        return new Promise(function (res, rej) {
            var onData;
            var free = function () { _this.httpRequest.removeListener("data", onData); };
            var resW = function (value) { free(); res(value); };
            var rejW = function (reason) { free(); rej(reason); };
            var chunkBuffer = [];
            _this.httpRequest.on("data", onData = function (chunk) { return chunkBuffer.push(chunk); });
            _this.httpRequest.once("close", function () { return rejW(new Error("socket closed prematurely")); }); // if end resolved, this doesn't reject promise
            _this.httpRequest.once("error", function (err) { return rejW(err); });
            _this.httpRequest.once("end", function () {
                var finalChunk = Buffer.concat(chunkBuffer);
                resW(finalChunk);
            });
        });
    };
    Object.defineProperty(NanoRequest.prototype, "Headers", {
        // public GetQueryStringValue(key: string): string | undefined | null {
        //     if (!this.httpRequest || !this.httpRequest.url) {
        //         return undefined;
        //     }
        //     key = key.replace(/[\[\]]/g, '\\$&');
        //     const regex = new RegExp('[?&]' + key + '(=([^&#]*)|&|#|$)');
        //     const results = regex.exec(this.httpRequest?.url!);
        //     if (!results) {
        //         return undefined;
        //     }
        //     if (!results[2]) {
        //         return null;
        //     }
        //     return decodeURIComponent(results[2].replace(/\+/g, ' '));
        // }
        get: function () {
            var _this = this;
            var retVal = {};
            Object.keys(this.httpRequest.headers).forEach(function (headerKey) {
                var header = _this.httpRequest.headers[headerKey];
                if (!header) {
                    return;
                }
                retVal[headerKey] = header instanceof Array ? header : [header];
            });
            return retVal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NanoRequest.prototype, "HeadersSingle", {
        get: function () {
            var _this = this;
            var retVal = {};
            Object.keys(this.httpRequest.headers).forEach(function (headerKey) {
                var header = _this.httpRequest.headers[headerKey];
                if (!header) {
                    return;
                }
                retVal[headerKey] = header instanceof Array ? header[0] : header;
            });
            return retVal;
        },
        enumerable: false,
        configurable: true
    });
    // public get QueryStringParams() {
    //     const retVal: Record<string, string | undefined> = {};
    //     const qString = this.httpRequest.url?.split("?")[1];
    //     if (qString) {
    //         const values = qString.split("&");
    //         values.forEach(value => {
    //             const val = value.split("=");
    //             retVal[val[0]] = val[1];
    //         });
    //     }
    //     return retVal;
    // }
    NanoRequest.prototype.GetQueryString = function () {
        var urlData = url_1.default.parse(this.httpRequest.url);
        if (!urlData.query) {
            return {};
        }
        var querystringData = querystring_1.default.parse(urlData.query);
        return querystringData;
    };
    return NanoRequest;
}());
exports.NanoRequest = NanoRequest;
;
//# sourceMappingURL=NanoRequest.js.map