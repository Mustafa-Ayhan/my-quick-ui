/// <reference types="node" />
import http from "http";
import { INanoService } from "./IService";
import { RouteParser, IParsedPath } from "./RouteParser";
import { IFileHandleResponse } from "./fileHandler";
import { INanoServerPlugin } from "../plugin/INanoServerPlugin";
import { IManageCors } from "@stechquick/symphony-common/lib/helpers/corsHelper";
declare type ILogCb = (logItem: {
    level: "error" | "warn" | "info" | "log" | "debug";
    message: string;
    error?: unknown;
    messageFunc?: () => string;
}) => void;
interface INanoServerStartOptions {
    port: number;
    successCb?: () => void;
    errorCb?: (error: Error) => void;
}
interface IServiceInternal extends INanoService {
    routeParser: RouteParser;
}
interface IHttpsStartOptions extends INanoServerStartOptions {
    privateKey?: string;
    certificate?: string;
}
export interface INanoServerOptions {
    rootDiskPath?: string;
    bindHost?: string;
    statusCodeRedirects?: Record<number, undefined | ((request: http.IncomingMessage, path: IParsedPath, returning: IFileHandleResponse) => IFileHandleResponse | null | Promise<IFileHandleResponse>)>;
    portSeekOffset?: number;
    manageCors?: IManageCors;
    staticFileServing?: "on" | "off";
    hostedPath?: string;
    backlog?: number;
    logOverride?: ILogCb;
}
export interface INanoServerOptionsInternal extends INanoServerOptions {
    httpOptions?: INanoServerStartOptions;
    httpsOptions?: IHttpsStartOptions;
    rootDiskPath: string;
    bindHost: string;
    statusCodeRedirects: Record<number, undefined | ((request: http.IncomingMessage, path: IParsedPath, returning: IFileHandleResponse) => IFileHandleResponse | null | Promise<IFileHandleResponse>)>;
    services?: Array<IServiceInternal>;
    staticFileServing: "on" | "off";
    hostedPath?: string;
    backlog: number;
    logOverride: ILogCb;
}
export declare class NanoServer {
    private server?;
    private options;
    private plugins;
    private promDatas;
    private portForcingTryCount;
    constructor(options?: INanoServerOptions);
    GetServerUrl(options?: {
        protocol?: "http" | "https";
    }): string | undefined;
    Subscribe(options: {
        event: "onStart";
        cb: () => void;
    }): void;
    Start(startingOptions: INanoServerStartOptions): Promise<void>;
    StartHttps(options: IHttpsStartOptions): Promise<void>;
    private attachPlugin;
    private StartNewServer;
    Stop(options?: {
        callback?: (err?: Error) => void;
        force?: boolean;
    }): void;
    ClearServices(): void;
    AddService(service: INanoService): void;
    AddPlugin(plugin: INanoServerPlugin): void;
    AddProxy(proxyOptions: Record<string, string>): void;
    GetOptions(): {
        bindHost: string;
        hostedPath: string | undefined;
        rootDiskPath: string;
        staticFileServing: "on" | "off";
        portSeekOffset: number | undefined;
        httpPort: number | undefined;
        httpsPort: number | undefined;
    };
    private retryForNextPort;
    private handleRequest;
    private subtractHostedPath;
    private tryHandleRequest;
    private isBinaryFile;
    private handleFileRequest;
    private handleService;
}
export {};
//# sourceMappingURL=NanoServer.d.ts.map