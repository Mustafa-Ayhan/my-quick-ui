{"version":3,"file":"RouteParser.js","sourceRoot":"","sources":["../../src/RouteParser.ts"],"names":[],"mappings":"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","sourcesContent":["import path from \"path\";\nimport url from \"url\";\n\nexport interface IParsedPath extends path.ParsedPath {\n    args: string\n};\n\nexport interface IMatchData {\n    matchLeftOver?: string,\n    args?: string\n}\nexport interface IMatchResult {\n    match: boolean;\n    power: number;\n    routeDict: Record<string, string>;\n    getMatchData?: () => IMatchData;\n};\n\nexport class RouteParser {\n    private staticParts: Array<string | null>;\n    private dynamicParts: Array<string | null>;\n\n    public constructor(templatePath: string) {\n        const pathParts: Array<string> = templatePath.split(\"/\").filter(pathPart => pathPart);\n        this.staticParts = Array(pathParts.length);\n        this.dynamicParts = Array(pathParts.length);\n        let counter = 0;\n\n        pathParts.forEach(pathPart => {\n            if (pathPart.startsWith(\"{\")) {\n                this.dynamicParts[counter] = pathPart.substring(1, pathPart.length - 1)\n            } else {\n                this.staticParts[counter] = pathPart.toLowerCase();\n            }\n            counter++;\n        });\n    }\n\n    public static ParseUrl(urlString: string): IParsedPath {\n        const urlData = url.parse(urlString);\n        const parsedPath = path.parse(urlData.pathname!);\n\n        let args = urlData.query ?? \"\";\n        return { ...parsedPath, ...{ args } };\n    }\n\n    public MatchAndGetRouteDict(parsedUrl: IParsedPath): IMatchResult {\n        const retVal: IMatchResult = { match: false, routeDict: {}, power: 0 };\n        const pureUrl = `${parsedUrl.dir}/${parsedUrl.name}${parsedUrl.ext}`;\n        const incommingPathParts = pureUrl.split(\"/\").filter(part => part);\n        if (incommingPathParts.length < this.staticParts.length) { return retVal; }\n\n        let counter = 0;\n        for (var i = 0, len = this.staticParts.length; i < len; i++) {\n            let dynamicPart = this.dynamicParts[i];\n            const currentStatic = this.staticParts[i];\n            retVal.match = true;\n            if (currentStatic == \"*\") {\n                break;\n            }\n            if (dynamicPart) {\n                retVal.routeDict[dynamicPart] = decodeURIComponent(incommingPathParts[i]);\n            } else if (incommingPathParts[counter].length > 0) {\n                if (incommingPathParts[counter].toLowerCase() != currentStatic) {\n                    retVal.match = false;\n                    break;\n                }\n\n            }\n            counter++;\n        }\n        if (retVal.match) {\n            retVal.getMatchData = () => ({\n                args: parsedUrl.args,\n                matchLeftOver: incommingPathParts.length >= counter ? incommingPathParts.slice(counter).map(item => \"/\" + item).join(\"\") : undefined,\n            });\n            retVal.power = counter;\n        }\n\n        return retVal;\n    }\n}"]}