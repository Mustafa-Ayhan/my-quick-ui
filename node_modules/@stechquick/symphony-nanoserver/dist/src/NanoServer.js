"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NanoServer = void 0;
var http_1 = __importDefault(require("http"));
var https_1 = __importDefault(require("https"));
var path_1 = __importDefault(require("path"));
var fs_1 = __importDefault(require("fs"));
var NanoRequest_1 = require("./NanoRequest");
var NanoResponse_1 = require("./NanoResponse");
var RouteParser_1 = require("./RouteParser");
var fileHandler_1 = require("./fileHandler");
var urlHelper_1 = require("./helpers/urlHelper");
var fileHelper_1 = require("./helpers/fileHelper");
var httpHelper_1 = require("./helpers/httpHelper");
var gracefulShutdown_1 = require("./gracefulShutdown");
var corsHelper_1 = require("@stechquick/symphony-common/lib/helpers/corsHelper");
var promiseData_1 = require("@stechquick/symphony-common/lib/helpers/promiseData");
var nanoValidations_1 = require("./validation/nanoValidations");
var pipeline_1 = require("./pipeline");
var defaults = {
    rootDiskPath: "./",
    bindHost: "0.0.0.0",
    statusCodeRedirects: {},
    staticFileServing: "on",
    backlog: 10,
    logOverride: function (item) {
        if (item.messageFunc) {
            item.message = item.messageFunc();
        }
        item.error ? console.error(item.message, item.error) : console.log(item.message);
    },
};
var noHostedPathDict = { "/": true, "": true };
var getHostName = function (host) {
    switch (host) {
        case defaults.bindHost:
        case "::": return "localhost";
        default: return host;
    }
};
;
;
var NanoServer = /** @class */ (function () {
    function NanoServer(options) {
        this.portForcingTryCount = 0;
        var newDef = Object.assign({}, defaults);
        if (options) {
            Object.keys(options).forEach(function (curKey) { var _a; return newDef[curKey] = (_a = options[curKey]) !== null && _a !== void 0 ? _a : newDef[curKey]; });
        }
        this.options = newDef;
        this.plugins = [];
        this.promDatas = {};
    }
    NanoServer.prototype.GetServerUrl = function (options) {
        if (options === void 0) { options = {}; }
        if (!this.options.httpOptions && !this.options.httpsOptions) {
            return undefined;
        }
        var protocol = options.protocol || (this.options.httpsOptions ? "https" : "http");
        var targetOptions = this.options[protocol + "Options"];
        if (!targetOptions) {
            return undefined;
        }
        var port = targetOptions.port;
        var logHost = getHostName(this.options.bindHost);
        return protocol + "://" + logHost + ":" + port;
    };
    NanoServer.prototype.Subscribe = function (options) {
        var promData = this.promDatas[options.event] = this.promDatas[options.event] || promiseData_1.CreatePromiseData();
        promData.promise.then(options.cb);
    };
    NanoServer.prototype.Start = function (startingOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var httpServer;
            return __generator(this, function (_a) {
                this.options.logOverride({ level: "log", message: "Starting http server..." });
                this.options.httpOptions = startingOptions;
                httpServer = http_1.default.createServer(this.handleRequest.bind(this));
                this.StartNewServer(httpServer, startingOptions);
                return [2 /*return*/];
            });
        });
    };
    NanoServer.prototype.StartHttps = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var httpsServer;
            return __generator(this, function (_a) {
                this.options.logOverride({ level: "log", message: "Starting https server..." });
                this.options.httpsOptions = options;
                httpsServer = https_1.default.createServer({ key: options.privateKey, cert: options.certificate }, this.handleRequest.bind(this));
                this.StartNewServer(httpsServer, options);
                return [2 /*return*/];
            });
        });
    };
    NanoServer.prototype.attachPlugin = function (plugin, server) {
        plugin.Attach(server);
        this.options.logOverride({ level: "debug", message: "plugin registered: " + plugin.PluginName });
    };
    NanoServer.prototype.StartNewServer = function (server, startingOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var optionsToLog, tryIt;
            var _this = this;
            return __generator(this, function (_a) {
                optionsToLog = JSON.parse(JSON.stringify(this.options));
                delete optionsToLog.services;
                this.options.logOverride({ level: "debug", message: "", messageFunc: function () { return "NanoServer options: " + JSON.stringify(optionsToLog); } });
                this.portForcingTryCount = 0;
                gracefulShutdown_1.addShutdown(server);
                tryIt = function () {
                    _this.options.logOverride({ level: "debug", message: "trying port: " + startingOptions.port });
                    var backlog = _this.options.backlog;
                    server.listen(startingOptions.port, _this.options.bindHost, backlog, (function () {
                        var _a, _b, _c;
                        _this.options.logOverride({ level: "debug", message: "found empty port: " + startingOptions.port + " listening backlog: " + backlog });
                        _this.options.logOverride({ level: "debug", message: "NS plugins: " + _this.plugins.length });
                        (_a = _this.plugins) === null || _a === void 0 ? void 0 : _a.forEach(function (plugin) { return _this.attachPlugin(plugin, server); });
                        _this.server = server;
                        (_b = _this.promDatas.onStart) === null || _b === void 0 ? void 0 : _b.resolver();
                        (_c = startingOptions === null || startingOptions === void 0 ? void 0 : startingOptions.successCb) === null || _c === void 0 ? void 0 : _c.call(startingOptions);
                    }));
                    server.on('error', function (error) {
                        var _a;
                        var isInUse = error.stack && ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.indexOf("EADDRINUSE")) > 0;
                        if (isInUse && _this.retryForNextPort()) {
                            _this.options.logOverride({ level: "warn", message: "port in use: " + startingOptions.port });
                            startingOptions.port++;
                            tryIt();
                        }
                        else {
                            if (!(startingOptions === null || startingOptions === void 0 ? void 0 : startingOptions.errorCb)) {
                                throw error;
                            }
                            startingOptions === null || startingOptions === void 0 ? void 0 : startingOptions.errorCb(error);
                        }
                    });
                };
                tryIt();
                return [2 /*return*/];
            });
        });
    };
    NanoServer.prototype.Stop = function (options) {
        if (!this.server) {
            return;
        }
        options = options || {};
        this.server.shutdown(options.force, options.callback);
        this.server.close();
        delete this.server;
    };
    NanoServer.prototype.ClearServices = function () {
        this.options.services = [];
    };
    NanoServer.prototype.AddService = function (service) {
        var _a;
        var routeParser = new RouteParser_1.RouteParser(this.subtractHostedPath(service.PathStart));
        this.options.services = (_a = this.options.services) !== null && _a !== void 0 ? _a : [];
        this.options.services.push(Object.assign(service, { routeParser: routeParser }));
    };
    NanoServer.prototype.AddPlugin = function (plugin) {
        this.plugins.push(plugin);
        if (!this.server) {
            return;
        } // during start, plugins are also attached
        this.attachPlugin(plugin, this.server);
    };
    NanoServer.prototype.AddProxy = function (proxyOptions) {
        var _this = this;
        var self = this;
        Object.keys(proxyOptions).forEach(function (sourceUrl) {
            var methods = ["DELETE", "GET", "OPTIONS", "POST", "PUT"];
            _this.AddService({
                PathStart: sourceUrl,
                Methods: new Set(methods), Execute: function (options) { return __awaiter(_this, void 0, void 0, function () {
                    var proxyTarget, parsed, protocolUrl, targetUrl, method, headers, body, targetUrl, targetPath, parsedPath, serviceOptions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                proxyTarget = proxyOptions[sourceUrl];
                                if (!urlHelper_1.UrlHelper.IsDirectUrl(proxyTarget)) return [3 /*break*/, 2];
                                parsed = urlHelper_1.UrlHelper.DetachProtocol(proxyTarget);
                                protocolUrl = (parsed.protocol ? parsed.protocol + "://" : "");
                                targetUrl = protocolUrl + path_1.default.posix.join(parsed.pureUrl, options.request.matchLeftover || "") + (options.request.args ? "?" + options.request.args : "");
                                method = options.request.httpRequest.method;
                                headers = options.request.httpRequest.headers;
                                if (headers.host) {
                                    delete headers.host;
                                    this.options.logOverride({ level: "debug", message: "removed host header" });
                                }
                                return [4 /*yield*/, options.request.GetBody()];
                            case 1:
                                body = _a.sent();
                                this.options.logOverride({ level: "log", message: "http redirect: " + sourceUrl + " --> " + targetUrl });
                                httpHelper_1.Proxy(options.response.httpResponse, targetUrl, { method: method, headers: headers, body: body });
                                return [3 /*break*/, 3];
                            case 2:
                                targetUrl = proxyTarget;
                                targetPath = path_1.default.join(targetUrl, options.request.matchLeftover || "");
                                if (fileHelper_1.IsRelativePath(targetUrl)) {
                                    targetPath = path_1.default.join(self.options.rootDiskPath, targetPath);
                                }
                                this.options.logOverride({ level: "log", message: "disk redirect: " + sourceUrl + " --> " + targetPath });
                                parsedPath = RouteParser_1.RouteParser.ParseUrl(targetPath);
                                serviceOptions = { request: new NanoRequest_1.NanoRequest(options.request.httpRequest, {}), response: new NanoResponse_1.NanoResponse(options.response.httpResponse) };
                                self.handleFileRequest("", parsedPath, serviceOptions);
                                _a.label = 3;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); }
            });
        });
    };
    // // where is this used ???
    // public GetServedFileList(): string[] {
    //     const getAllFiles = (dirPath: string, arrayOfFiles?: string[]) => {
    //         const files = fs.readdirSync(dirPath)
    //         arrayOfFiles = arrayOfFiles || [];
    //         files.forEach((file) => {
    //             if (fs.statSync(dirPath + "/" + file).isDirectory()) {
    //                 arrayOfFiles = getAllFiles(dirPath + "/" + file, arrayOfFiles);
    //             } else {
    //                 const fullPath = path.join(dirPath, file);
    //                 const item = this.GetServerUrl() + fullPath.replace(this.options.rootDiskPath, "").replace(/\\/gi, "/");
    //                 arrayOfFiles!.push(item);
    //             }
    //         });
    //         return arrayOfFiles
    //     }
    //     return getAllFiles(this.options.rootDiskPath);
    // }
    NanoServer.prototype.GetOptions = function () {
        var _a, _b;
        var _c = this.options, bindHost = _c.bindHost, hostedPath = _c.hostedPath, rootDiskPath = _c.rootDiskPath, staticFileServing = _c.staticFileServing, portSeekOffset = _c.portSeekOffset;
        var retVal = {
            bindHost: bindHost, hostedPath: hostedPath, rootDiskPath: rootDiskPath, staticFileServing: staticFileServing, portSeekOffset: portSeekOffset,
            httpPort: (_a = this.options.httpOptions) === null || _a === void 0 ? void 0 : _a.port,
            httpsPort: (_b = this.options.httpsOptions) === null || _b === void 0 ? void 0 : _b.port
        };
        return retVal;
    };
    NanoServer.prototype.retryForNextPort = function () {
        var forcingCount = this.options.portSeekOffset;
        if (forcingCount && forcingCount > this.portForcingTryCount) {
            this.portForcingTryCount++;
            return true;
        }
        return false;
    };
    NanoServer.prototype.handleRequest = function (request, response) {
        return __awaiter(this, void 0, void 0, function () {
            var err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.tryHandleRequest(request, response)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _a.sent();
                        this.options.logOverride({ level: "error", message: "Ex in request handing: ", error: err_1 });
                        response.writeHead(500, { "Content-Type": "text/html; charset=utf-8", "Content-Length": 0 });
                        response.end();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    NanoServer.prototype.subtractHostedPath = function (url) {
        if (!this.options.hostedPath || noHostedPathDict[this.options.hostedPath] || !url.startsWith(this.options.hostedPath)) {
            return url;
        }
        var hostedPathLength = this.options.hostedPath.length;
        if (this.options.hostedPath[hostedPathLength - 1] == "/") {
            hostedPathLength--;
        }
        return url.slice(hostedPathLength);
    };
    NanoServer.prototype.tryHandleRequest = function (request, response) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var url, parsedUrl, serviceOptions, validationResp, _c, content, handleResponse, handleResponseOverride;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        url = request.url || "";
                        url = this.subtractHostedPath(url);
                        this.options.logOverride({ level: "debug", message: "->: " + url });
                        parsedUrl = RouteParser_1.RouteParser.ParseUrl(url);
                        serviceOptions = { request: new NanoRequest_1.NanoRequest(request, {}), response: new NanoResponse_1.NanoResponse(response) };
                        validationResp = new nanoValidations_1.NanoValidations().ValidateUrl(parsedUrl);
                        if (!validationResp) return [3 /*break*/, 2];
                        return [4 /*yield*/, new pipeline_1.Pipeline().Respond(validationResp, serviceOptions, parsedUrl, this.options)];
                    case 1:
                        _d.sent();
                        return [2 /*return*/];
                    case 2:
                        //fix root
                        if (parsedUrl.dir == "/" && parsedUrl.base == "") {
                            parsedUrl.name = "index";
                            parsedUrl.ext = ".html";
                            parsedUrl.base = parsedUrl.name + parsedUrl.ext;
                        }
                        return [4 /*yield*/, this.handleService(parsedUrl, serviceOptions)];
                    case 3:
                        if (_d.sent()) {
                            return [2 /*return*/];
                        }
                        _c = this.options.staticFileServing == "on";
                        if (!_c) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.handleFileRequest(this.options.rootDiskPath, parsedUrl, serviceOptions, this.options.manageCors)];
                    case 4:
                        _c = (_d.sent());
                        _d.label = 5;
                    case 5:
                        if (_c) {
                            return [2 /*return*/];
                        }
                        content = "Service Unavailable: " + url.substring(0, 50) + (url.length > 50 ? "..." : "");
                        handleResponse = {
                            content: content,
                            headers: { "Content-Type": "text/html; charset=utf-8", "Content-Length": content.length.toString() }, status: 503
                        };
                        return [4 /*yield*/, ((_b = (_a = this.options.statusCodeRedirects)[503]) === null || _b === void 0 ? void 0 : _b.call(_a, serviceOptions.request.httpRequest, parsedUrl, handleResponse))];
                    case 6:
                        handleResponseOverride = (_d.sent()) || handleResponse;
                        this.options.logOverride({ level: "debug", message: "", messageFunc: function () { return "<- " + handleResponse.status; } });
                        response.writeHead(handleResponseOverride.status, handleResponseOverride.headers);
                        response.end(handleResponseOverride.content, "utf-8");
                        return [2 /*return*/];
                }
            });
        });
    };
    NanoServer.prototype.isBinaryFile = function (ext) {
        var mimeTypes = {
            '.html': false,
            '.js': false,
            '.css': false,
            '.json': false,
            '.png': true,
            '.jpg': true,
            '.gif': true,
            '.wav': true,
            '.mp4': true,
            '.woff': true,
            '.ttf': true,
            '.eot': false,
            '.otf': false,
            '.svg': false,
            ".dll": false,
            ".txt": false,
        };
        return mimeTypes[ext];
    };
    NanoServer.prototype.handleFileRequest = function (basePath, parsedPath, serviceOptions, manageCors) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var method, origin, corsResp, resp, filePath, stream, self_1, fileResponse, redirect;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (manageCors) {
                            method = serviceOptions.request.httpRequest.method;
                            origin = serviceOptions.request.httpRequest.headers.origin;
                            corsResp = corsHelper_1.CorsManager.ManageCors({ method: method, origin: origin ? [origin] : undefined }, manageCors);
                            if (!corsResp.success) {
                                resp = serviceOptions.response.httpResponse;
                                resp.statusCode = corsResp.statusCode;
                                resp.end(corsResp.message);
                                return [2 /*return*/, true];
                            }
                            serviceOptions.response.writeHeaders(corsResp.headers);
                        }
                        if (this.isBinaryFile(parsedPath.ext)) {
                            filePath = path_1.default.resolve(path_1.default.join(basePath, parsedPath.dir, parsedPath.base));
                            stream = fs_1.default.createReadStream(filePath);
                            stream.on('open', function () {
                                stream.pipe(serviceOptions.response.httpResponse);
                            });
                            self_1 = this;
                            stream.on('error', function (e) {
                                var status = 404;
                                self_1.options.logOverride({ level: "error", message: "Image error:", error: e });
                                self_1.options.logOverride({ level: "debug", message: "", messageFunc: function () { return "<- " + status; } });
                                serviceOptions.response.httpResponse.setHeader('Content-Type', 'text/plain');
                                serviceOptions.response.httpResponse.statusCode = status;
                                serviceOptions.response.httpResponse.end('Not found');
                            });
                            return [2 /*return*/, true];
                        }
                        fileResponse = new fileHandler_1.FileHandler().handleFileRequest(basePath, parsedPath);
                        return [4 /*yield*/, ((_c = (_a = this.options) === null || _a === void 0 ? void 0 : (_b = _a.statusCodeRedirects)[fileResponse.status]) === null || _c === void 0 ? void 0 : _c.call(_b, serviceOptions.request.httpRequest, parsedPath, fileResponse))];
                    case 1:
                        redirect = _d.sent();
                        if (redirect) {
                            fileResponse = redirect;
                            this.options.logOverride({ level: "debug", message: "", messageFunc: function () { return "custom redirect status: " + redirect.status + " headers:" + JSON.stringify(redirect.headers || {}); } });
                        }
                        this.options.logOverride({ level: "debug", message: "", messageFunc: function () { return "<- " + fileResponse.status; } });
                        serviceOptions.response.httpResponse.writeHead(fileResponse.status, fileResponse.headers);
                        serviceOptions.response.httpResponse.end(fileResponse.content, "utf-8");
                        return [2 /*return*/, true];
                }
            });
        });
    };
    NanoServer.prototype.handleService = function (parsedUrl, serviceOptions) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var retVal, method, initialObj, matchResult, matchData;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        retVal = false;
                        method = serviceOptions.request.httpRequest.method;
                        if (!this.options.services || !method) {
                            return [2 /*return*/, retVal];
                        }
                        initialObj = { result: { match: false, routeDict: {}, power: 0 } };
                        matchResult = this.options.services.reduce(function (prev, service) {
                            if (!service.Methods.has(method)) {
                                return prev;
                            }
                            var matchResult = service.routeParser.MatchAndGetRouteDict(parsedUrl);
                            if (!matchResult.match) {
                                return prev;
                            }
                            return matchResult.power > prev.result.power ? { service: service, result: matchResult } : prev;
                        }, initialObj);
                        if (!matchResult.result.match) return [3 /*break*/, 2];
                        retVal = true;
                        serviceOptions.request.routeDict = matchResult.result.routeDict;
                        matchData = (_b = (_a = matchResult.result).getMatchData) === null || _b === void 0 ? void 0 : _b.call(_a);
                        serviceOptions.request.matchLeftover = matchData === null || matchData === void 0 ? void 0 : matchData.matchLeftOver;
                        serviceOptions.request.args = matchData === null || matchData === void 0 ? void 0 : matchData.args;
                        return [4 /*yield*/, matchResult.service.Execute(serviceOptions)];
                    case 1:
                        _c.sent();
                        _c.label = 2;
                    case 2: return [2 /*return*/, retVal];
                }
            });
        });
    };
    return NanoServer;
}());
exports.NanoServer = NanoServer;
//# sourceMappingURL=NanoServer.js.map