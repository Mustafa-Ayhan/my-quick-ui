import { SocketDataType } from "@stechquick/algae/lib/helpers/socket/iSocket";
import * as ws from "ws";
import { NanoSocket } from "./nanoSocket";
declare type NSRelayerOnMessagesResponses = {
    changeRelayMsg: {
        type: "changeRelayMsg";
        msg?: ws.Data;
        destinationUIDs?: Array<string>;
    };
    noProcessNoRelay: {
        type: "noProcessNoRelay";
    };
    processButNoRelay: {
        type: "processButNoRelay";
    };
    continueRelay: {
        type: "continueRelay";
    };
};
export interface INanoSocketRelayerOptions {
    onMessage?: (senderType: "source" | "target", sender: NanoSocket, msg: SocketDataType) => NSRelayerOnMessagesResponses[keyof NSRelayerOnMessagesResponses] | undefined | null;
}
interface IRemoveTargetOptions {
    /**
     * message to be sent to target being removed
     */
    removeMessage?: string | object;
}
interface IStopRelayOptions {
    /**
     * message to be sent to all clients while stopping relay
     */
    stopMessage?: string | object;
}
interface ITargetOptions {
    onClose?: () => void;
}
interface ITargetData {
    ns: NanoSocket;
    options?: ITargetOptions;
}
export declare class NanoSocketRelayer {
    private source;
    private targets;
    private options?;
    private backup?;
    constructor(source: NanoSocket, options?: INanoSocketRelayerOptions);
    StartRelay(): boolean;
    private backupAndConnect;
    AddTarget(targetSocket: NanoSocket, options: ITargetOptions): void;
    RemoveTarget(targetUID: string, options: IRemoveTargetOptions): ITargetData | undefined;
    StopRelay(options: IStopRelayOptions): boolean;
    private relay;
    private filterTargets;
    GetTargetUIDs(): string[];
}
export {};
//# sourceMappingURL=nanoSocketRelayer.d.ts.map