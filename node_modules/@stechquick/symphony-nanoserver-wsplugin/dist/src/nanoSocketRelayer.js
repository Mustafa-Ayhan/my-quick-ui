"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NanoSocketRelayer = void 0;
var NanoSocketRelayer = /** @class */ (function () {
    function NanoSocketRelayer(source, options) {
        this.source = source;
        this.targets = {};
        this.options = options;
    }
    NanoSocketRelayer.prototype.StartRelay = function () {
        var _this = this;
        if (this.backup) {
            return true;
        }
        this.backup = { sourceOnMessage: this.source.OnMessage, targetOnMessages: {} };
        this.source.OnMessage = function (message) { return _this.relay("source", _this.source, message); };
        var targetUIDs = this.GetTargetUIDs();
        targetUIDs.forEach(function (targetUID) { return _this.backupAndConnect(_this.targets[targetUID]); });
        console.log("[" + this.source.UID + "-" + this.source.ID + "] started as relay source to " + targetUIDs.length + " targets");
        return true;
    };
    NanoSocketRelayer.prototype.backupAndConnect = function (target) {
        var _this = this;
        this.backup.targetOnMessages[target.ns.UID] = target.ns.OnMessage;
        target.ns.OnMessage = function (message) { return _this.relay("target", target.ns, message); };
        var targetOnClose = target.ns.OnClose;
        target.ns.OnClose = function () {
            var _a;
            var options = target.options;
            _this.RemoveTarget(target.ns.UID, {});
            target.ns.OnClose = targetOnClose;
            targetOnClose === null || targetOnClose === void 0 ? void 0 : targetOnClose();
            (_a = options === null || options === void 0 ? void 0 : options.onClose) === null || _a === void 0 ? void 0 : _a.call(options);
        };
        console.log("[" + target.ns.UID + "-" + target.ns.ID + "] started as relay target");
    };
    NanoSocketRelayer.prototype.AddTarget = function (targetSocket, options) {
        if (!this.backup) {
            this.StartRelay();
        }
        var target = this.targets[targetSocket.UID] = { ns: targetSocket, options: options };
        if (!this.backup) {
            return;
        } // will connect
        this.backupAndConnect(target);
    };
    NanoSocketRelayer.prototype.RemoveTarget = function (targetUID, options) {
        var target = this.targets[targetUID];
        if (!target) {
            return undefined;
        }
        target.ns.OnMessage = this.backup.targetOnMessages[targetUID];
        if (options.removeMessage) {
            target.ns.Send(options.removeMessage);
        }
        delete this.targets[targetUID];
        delete this.backup.targetOnMessages[targetUID];
        delete target.options;
        console.log("[" + target.ns.UID + "-" + target.ns.ID + "] removed as relay target " + (options.removeMessage ? "- with removeMsg" : ""));
        return target;
    };
    NanoSocketRelayer.prototype.StopRelay = function (options) {
        var _this = this;
        if (!this.backup) {
            return true;
        }
        this.source.OnMessage = this.backup.sourceOnMessage;
        var targetUIDs = this.GetTargetUIDs();
        targetUIDs.forEach(function (targetUID) { return _this.RemoveTarget(targetUID, { removeMessage: options.stopMessage }); });
        console.log("[" + this.source.UID + "-" + this.source.ID + "] stopped relay. Removed " + targetUIDs.length + " targets " + (options.stopMessage ? "- with stopMsg" : ""));
        this.targets = {};
        this.backup = undefined;
        return true;
    };
    NanoSocketRelayer.prototype.relay = function (senderType, sender, message) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        var relayMessage = message;
        var relayOverride = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.onMessage) === null || _b === void 0 ? void 0 : _b.call(_a, senderType, sender, message);
        var targettedRelayDestinationUIDs;
        switch (relayOverride === null || relayOverride === void 0 ? void 0 : relayOverride.type) {
            case "changeRelayMsg":
                relayMessage = relayOverride.msg || relayMessage;
                targettedRelayDestinationUIDs = this.filterTargets(relayOverride.destinationUIDs, senderType);
                break;
            case "continueRelay": break;
            case "processButNoRelay":
                (_e = (senderType == "source" ? (_c = this.backup) === null || _c === void 0 ? void 0 : _c.sourceOnMessage : (_d = this.backup) === null || _d === void 0 ? void 0 : _d.targetOnMessages[sender.UID])) === null || _e === void 0 ? void 0 : _e(message);
                return;
            case "noProcessNoRelay": return;
        }
        if (senderType == "source") {
            var targetUIDs = targettedRelayDestinationUIDs !== null && targettedRelayDestinationUIDs !== void 0 ? targettedRelayDestinationUIDs : this.GetTargetUIDs();
            targetUIDs.forEach(function (targetUID) { return _this.targets[targetUID].ns.Send(relayMessage); });
            console.log("[" + this.source.UID + "-" + this.source.ID + "] msg --> to " + targetUIDs.length + " targets");
        }
        else {
            this.source.Send(relayMessage);
            console.log("[" + this.source.UID + "-" + this.source.ID + "] msg <-- from target " + sender.UID + "-" + sender.ID);
        }
    };
    NanoSocketRelayer.prototype.filterTargets = function (UIDs, senderType) {
        var _this = this;
        if (!UIDs) {
            return undefined;
        }
        if (senderType == "target") {
            return UIDs;
        }
        var filtered = UIDs.reduce(function (prev, UID) {
            var target = _this.targets[UID] == undefined ? prev.invalids : prev.valids;
            target.push(UID);
            return prev;
        }, { valids: [], invalids: [] });
        if (filtered.invalids.length <= 0) {
            return UIDs;
        }
        console.log("[" + this.source.UID + "-" + this.source.ID + "] --> msg targets not found: ", filtered.invalids);
        return filtered.valids;
    };
    NanoSocketRelayer.prototype.GetTargetUIDs = function () {
        return Object.keys(this.targets);
    };
    return NanoSocketRelayer;
}());
exports.NanoSocketRelayer = NanoSocketRelayer;
//# sourceMappingURL=nanoSocketRelayer.js.map