import { symphony, IRestResponse, ISoapResponse } from "@stechquick/symphony";

let func = symphony.retrieveFunction(() => require("../functions/samplefunc/samplefunc"));

// it equals just a test case 
it('should get receive an error', async () => {
    const sym = symphony.createMock();
 
    //sym.request.body data is mocking as 4 and 6
    sym.request.body = { number1: 4, number2: 6 };

    sym.rest.get = (options) => {
        //sym.rest.get one of the options values, symConfigKey, is testing before mocking
        expect(options.symConfigKey).toBe("restGetExample");
        options.symConfigKey="urlGetMock"; //=> symConfigKey is mocking
        expect(options.symConfigKey).toBe("urlGetMock");//=> symConfigKey is testing after mocking
        //sym.rest.get response is mocking
        const returnGetVal: IRestResponse<any> = { status: 200, statusText: "OK", body: { x:5 } };
        return Promise.resolve(returnGetVal);
    }

    sym.rest.post = (options) => {
        //sym.rest.post one of the options values, symConfigKey, is testing before mocking
        expect(options.symConfigKey).toBe("restPostExample");
        //sum and difference results sending as parameters in body of sym.rest.post for real function
        const requestBody= <any>options.body;
        expect(requestBody.name).toBe("test");
        expect(requestBody.salary).toBe("123");
        //sym.rest.post response is mocking
        const returnPostVal: IRestResponse<any> = { status: 200, statusText: "OK", body: { a:7,b:8  } };
        return Promise.resolve(returnPostVal);
    };

    sym.soap.request=(options)=>{
        //sym.soap.request one of the options values, methodName, is tested before mocking
        expect(options.request.methodName).toBe("Add");
        options.request.methodName="functionMock";//=> options.request.methodName is mocking
        const methodName=<any>options.request.methodName;
         //sym.soap.request response is mocking
        const returnSoapVal: ISoapResponse = { data: {methodName}};
        return Promise.resolve(returnSoapVal);
    };
    
    const resp = await func(sym);
   
    expect(resp.body.calculations.sum).toBe(10);
    expect(resp.body.calculations.difference).toBe(2);
    expect(resp.body.soapResponse.total).toEqual({methodName: "functionMock"});
    expect(resp.body.restGetResponse.listEmp).toEqual({ x:5 })
    expect(resp.body.restPostResponse.listEmp).toEqual({ a:7,b:8  })

     //toBe function is matcher for type of number and string
    //toEqual function is matcher for type of object or number or string
    //for more matchers: https://jestjs.io/docs/en/using-matchers
});