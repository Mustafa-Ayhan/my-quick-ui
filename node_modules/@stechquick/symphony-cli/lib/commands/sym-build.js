"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const npmHelper_1 = require("../helpers/npmHelper");
const initHelper_1 = require("../helpers/initHelper");
const packageHelper_1 = require("../helpers/packageHelper");
const cli_ux_1 = require("cli-ux");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("../helpers/chalk");
const swaggerHelper_1 = require("../helpers/swaggerHelper");
class Build extends command_1.Command {
    async run() {
        const { flags } = this.parse(Build);
        //assert in folder control
        if (!initHelper_1.InitHelper.AssertInFolder()) {
            return;
        }
        //version control
        let bwPackages = [];
        if (!flags.skipversion) {
            log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Version checking, please wait...") });
            bwPackages = packageHelper_1.PackageHelper.getBackwardPackages(Build.versionCheckSetting);
        }
        else {
            log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Skipping version checking...") });
        }
        if (bwPackages.length == 0) {
            this.continueToBuild(flags.watch, flags.local_js_dist_path);
            return;
        }
        log_1.Logger.log({ message: chalk_1.Chalk.create("yellow.bold", "There are backward packages!\n"), additional: bwPackages });
        cli_ux_1.cli.confirm(chalk_1.Chalk.create("yellow.bold", "Do you want to continue? [Y/N]")).then(res => {
            if (!res) {
                log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", "Build stopped...") });
                return;
            }
            log_1.Logger.log({ message: chalk_1.Chalk.create("yellow", "Continue to build. (I hope you are aware of what you are doing...)") });
            this.continueToBuild(flags.watch, flags.local_js_dist_path);
        });
    }
    async continueToBuild(watch, local_js_dist_path) {
        npmHelper_1.NpmHelper.build({ watch });
        const { flags } = this.parse(Build);
        if (flags.swagger)
            await new swaggerHelper_1.SwaggerHelper().Swagger("./functions", local_js_dist_path);
        if (flags.swagger && flags.swaggerInclusive)
            new swaggerHelper_1.SwaggerHelper().SwaggerSchemaInclusive(local_js_dist_path);
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Swagger created/updated successfully."), timeFormat: "datetime" });
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Build finished successfully."), timeFormat: "datetime" });
    }
}
exports.default = Build;
Build.description = 'Plateau-Symphony command to build the app with/without watch';
Build.examples = [
    "$ symphony-cli sym-build",
    "$ symphony-cli sym-build -w",
    "$ symphony-cli sym-build --swagger",
    "$ symphony-cli sym-build --swagger -i",
    "$ symphony-cli sym-build --swagger -l ./dist/api/local.js",
];
Build.flags = {
    watch: command_1.flags.boolean({ char: 'w', description: 'for watch' }),
    skipversion: command_1.flags.boolean({ char: 's', description: 'skip version checking. Used for Deployment' }),
    swagger: command_1.flags.boolean({ description: 'for swagger generation, this parameter must be given' }),
    swaggerInclusive: command_1.flags.boolean({ char: 'i', description: 'to make swagger schema inclusive' }),
    local_js_dist_path: command_1.flags.string({ char: "l", description: "for monorepos, if local.js is not directly under dist. like: ./dist/api/local.js" }),
};
Build.versionCheckSetting = {
    packageNames: ["@stechquick\/\symphony", "@stechquick\/\symphony-cli"],
    packageJsonFilePath: "/templates/init/{{AppName}}/{{remove}}package.json"
};
