"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const path = tslib_1.__importStar(require("path"));
const symphony_nanoserver_1 = require("@stechquick/symphony-nanoserver");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("../helpers/chalk");
const socketServerHelper_1 = require("../helpers/socketServer/socketServerHelper");
class Serve extends command_1.Command {
    constructor() {
        super(...arguments);
        this.rootPath = "";
    }
    async run() {
        var _a;
        const { flags } = this.parse(Serve);
        this.rootPath = (_a = flags.path) !== null && _a !== void 0 ? _a : path.resolve(".");
        this.createServer();
        this.addServicesToServer();
        await this.startServer(flags.httpPort);
        this.attachPlugins(); // attach plugin waits for server start
    }
    createServer() {
        Serve.server = new symphony_nanoserver_1.NanoServer({
            rootDiskPath: this.rootPath,
            bindHost: global ? "0.0.0.0" : "127.0.0.1",
            portSeekOffset: 1000,
            manageCors: {}
        });
    }
    addServicesToServer() {
        Serve.server.AddService({
            PathStart: "/ping",
            Methods: new Set(["GET"]),
            Execute: async (options) => options.response.writeResponse(`Hi from symphony-cli quick server.<br> Root path: ${this.rootPath}`)
        });
    }
    attachPlugins() {
        new socketServerHelper_1.SocketServerHelper(Serve.server).Start();
    }
    async startServer(httpPort) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Server starting..."), timeFormat: "datetime" });
        Serve.server.Start({
            port: httpPort || 3007,
            successCb: () => {
                log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", `Http listening on: ${Serve.server.GetServerUrl()}`) });
            }
        });
        // Serve.server.StartHttps({
        //     port: 3030,
        //     privateKey: fs.readFileSync('key.pem', 'utf8'),
        //     certificate: fs.readFileSync('cert.pem', 'utf8'),
        //     successCb: () => {
        //         //Logger.log({ message: Chalk.create("green.bold", `Https listening on: ${Serve.server.GetServerUrl()}`) });
        //     }
        // });
    }
}
exports.default = Serve;
Serve.description = 'QUICK command for serving your path';
Serve.examples = [
    "$ symphony-cli quick-serve",
    "$ symphony-cli quick-serve -p 3000",
    "$ symphony-cli quick-serve -g",
    "$ symphony-cli quick-serve -r C:/MyPathToServe",
    "$ symphony-cli quick-serve -g -r C:/MyPathToServe"
];
Serve.flags = {
    path: command_1.flags.string({ char: 'r', description: 'Change path to serve' }),
    httpPort: command_1.flags.integer({ char: 'p', description: 'HTTP port to serve' }),
    global: command_1.flags.boolean({ char: 'g', description: 'Host/visible for everyone.' })
};
