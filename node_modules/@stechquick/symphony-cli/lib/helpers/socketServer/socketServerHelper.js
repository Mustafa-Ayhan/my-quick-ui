"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketServerHelper = void 0;
const tslib_1 = require("tslib");
const symphony_nanoserver_wsplugin_1 = require("@stechquick/symphony-nanoserver-wsplugin");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("../../helpers/chalk");
const cryptoHelper_1 = require("@stechquick/symphony-common/lib/helpers/cryptoHelper");
const fileHelper_1 = require("@stechquick/symphony-common/lib/helpers/fileHelper");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const packageHelper_1 = require("../packageHelper");
const version_1 = require("@stechquick/algae/lib/helpers/version");
class SocketServerHelper {
    constructor(server) {
        this.version = packageHelper_1.PackageHelper.getCliPackageJson().version;
        this.server = server;
        this.nss = new symphony_nanoserver_wsplugin_1.NanoSocketServer({
            onConnection: this.onSocketConnection.bind(this),
            onError: this.onSocketError.bind(this)
        });
        this.messageTypeLookup = {
            "list_files": this.listFilesExecution.bind(this),
            "save_files": this.saveFilesExecution.bind(this),
            "create_folder": this.createFolderExecution.bind(this),
            "delete_folder": this.deleteFolderExecution.bind(this),
            "delete_files": this.deleteFilesExecution.bind(this),
            "get_files": this.getFilesExecution.bind(this),
            "file_change": this.getFilesExecution.bind(this),
            "watch_files": this.getFilesExecution.bind(this),
            get_version: async (msg) => this.getVersion(msg),
        };
    }
    Start() {
        this.server.AddPlugin(this.nss);
        return this;
    }
    onSocketConnection(ns) {
        const timer = setTimeout(() => {
            log_1.Logger.log({ message: chalk_1.Chalk.create("red", "unverified client") });
            ns.Close(4001, "unverified client");
        }, 3 * 1000);
        ns.OnMessage = (msg) => {
            if (msg != "hello cli") {
                return;
            }
            clearTimeout(timer);
            ns.Send("hello nemo");
            ns.OnMessage = verifiedOnMsg;
        };
        const verifiedOnMsg = async (msg) => {
            const request = JSON.parse(msg.toString());
            const msgHandler = this.messageTypeLookup[request.msg.type];
            if (!msgHandler) {
                log_1.Logger.log({ message: `unsupported message: ${request.msg.type}.  ${chalk_1.Chalk.create("yellow.bold", "update might be required.")}` });
                return;
            }
            const res = await msgHandler(request.msg);
            if (!res) {
                return;
            }
            const networkRes = {
                id: cryptoHelper_1.CryptoHelper.CreateGuid(),
                msg: res,
                reply: request.id
            };
            ns.Send(networkRes);
        };
        console.log("connected", ns.ID);
    }
    onSocketError(error) {
    }
    async listFilesExecution(msg) {
        const selectedPath = path.resolve(msg.path || ".");
        return {
            curPath: selectedPath,
            type: "list_files_resp",
            files: fileHelper_1.FileHelper.getFileNamesFormPath({ selectedPath })
        };
    }
    async saveFilesExecution(msg) {
        try {
            const filePaths = msg.files.map(file => {
                var _a;
                const filePath = path.resolve(file.name + ((_a = file.ext) !== null && _a !== void 0 ? _a : ""));
                const directory = path.dirname(filePath);
                if (msg.recursive && !fs.existsSync(directory)) {
                    fs.mkdirSync(directory, { recursive: true });
                }
                if (file.type == "base64convertedfile") {
                    const base64Image = file.content;
                    const base64Data = base64Image.split(',')[1];
                    const imageBuffer = Buffer.from(base64Data, 'base64');
                    fs.writeFileSync(filePath, imageBuffer);
                }
                else
                    fs.writeFileSync(filePath, file.content, { encoding: "UTF8" });
                return filePath;
            });
            return { type: "save_files_resp", result: true, filePaths };
        }
        catch (error) {
            log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", `Saving files error!`), error, level: log_1.LogLevel.error });
            return { type: "save_files_resp", result: false };
        }
    }
    async createFolderExecution(msg) {
        try {
            if (!fs.existsSync(msg.folderName)) {
                fs.mkdirSync(msg.folderName, { recursive: true });
            }
            return { type: "create_folder_resp" };
        }
        catch (error) {
            log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", `Creating folder error!`), error, level: log_1.LogLevel.error });
            return { type: "create_folder_resp" };
        }
    }
    async deleteFolderExecution(msg) {
        if (!fs.existsSync(msg.folderName)) {
            // Return early if the folder does not exist
            return { type: "delete_folder_resp" };
        }
        try {
            var rmdir = function (dir) {
                var list = fs.readdirSync(dir);
                for (var i = 0; i < list.length; i++) {
                    var filename = path.join(dir, list[i]);
                    var stat = fs.statSync(filename);
                    if (stat.isDirectory()) {
                        rmdir(filename);
                    }
                    else {
                        fs.unlinkSync(filename);
                    }
                }
                fs.rmdirSync(dir);
            };
            rmdir(msg.folderName);
            return { type: "delete_folder_resp" };
        }
        catch (error) {
            log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", `Deleting folder error!`), error, level: log_1.LogLevel.error });
            return { type: "delete_folder_resp" };
        }
    }
    async deleteFilesExecution(msg) {
        try {
            msg.files.forEach(file => {
                fs.unlinkSync(path.resolve(file));
            });
            return { type: "delete_files_resp", result: true };
        }
        catch (error) {
            log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", `Deleting files error!`), error, level: log_1.LogLevel.error });
            return { type: "delete_files_resp", result: true };
        }
    }
    async getFilesExecution(msg) {
        const retFiles = [];
        msg.files.forEach(file => {
            const content = fs.readFileSync(path.resolve(file), { encoding: "UTF8" });
            retFiles.push({ content, name: file, type: "file" });
        });
        return { files: retFiles, type: "get_files_resp" };
    }
    async checkUpdateRequired(msg) {
        if (!msg.minRequired) {
            return;
        }
        if (version_1.compareVersion(msg.minRequired, this.version) != 1) {
            return;
        }
        log_1.Logger.log({ message: `Cli tool ${chalk_1.Chalk.create("yellow.bold", "UPDATE required")}. Studio requires cli version: ${chalk_1.Chalk.create("green.bold", msg.minRequired)}. Yours: ${chalk_1.Chalk.create("red.bold", this.version)}`, level: log_1.LogLevel.warn });
    }
    async getVersion(msg) {
        await this.checkUpdateRequired(msg);
        return { type: "get_version_response", version: this.version };
    }
}
exports.SocketServerHelper = SocketServerHelper;
