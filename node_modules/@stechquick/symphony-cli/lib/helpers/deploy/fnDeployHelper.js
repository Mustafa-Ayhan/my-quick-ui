"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnDeployHelper = void 0;
const tslib_1 = require("tslib");
const fnPostdeploy_1 = require("../../predeploy/src/fn/fnPostdeploy");
const shellHelper_1 = require("../shellHelper");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs"));
const initHelper_1 = require("../initHelper");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("../chalk");
const fnDownloadHelper_1 = require("../fnDownloadHelper");
const fnPredeploy_1 = require("../../predeploy/src/fn/fnPredeploy");
class FnDeployHelper {
    constructor(settings) {
        this.settings = settings;
    }
    async deploy() {
        if (!initHelper_1.InitHelper.AssertInFolder()) {
            return;
        }
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Deploy starting..."), timeFormat: "datetime" });
        let success = false;
        try {
            const fnFileName = await new fnDownloadHelper_1.FnDownloadHelepr().downloadFn();
            if (this.settings.environment == "local") {
                await this.fnContext("default", fnFileName);
            }
            else {
                await this.fnPreRemote(fnFileName);
            }
            await fnPredeploy_1.FnPredeploy.execute(this.getReplaceWords());
            await this.fnDeploy(fnFileName);
            success = true;
        }
        finally {
            fnPostdeploy_1.FnPostDeploy.execute();
            if (!success) {
                log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", "Deploy failed, ^^ search for errors up ^^"), timeFormat: "datetime" });
            }
            else {
                log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Deploy complete"), timeFormat: "datetime" });
            }
        }
    }
    getReplaceWords() {
        let data = { environmentalVars: "" };
        if (this.settings.nodeEnv) {
            data.environmentalVars = `ENV NODE_ENV=${this.settings.nodeEnv}`;
        }
        //!!! Orbay: Bu böyle yönetilmemeli! Geçici yazıldı. Sanki app'in içinden bir yerden almalı bu bilgiyi???
        if (this.settings.environment == "remote") {
            data.registryHostName = "nexus-service";
        }
        else {
            data.registryHostName = "nexus.rally.softtech";
        }
        return data;
    }
    getDockerCommandArgs() {
        let args = [
            "login",
            "--username",
            this.settings.dockerSettings.username,
            "--password",
            this.settings.dockerSettings.password
        ];
        if (this.settings.environment == "remote") {
            args.push(this.settings.dockerSettings.url);
        }
        return args;
    }
    getFnCommandArgs() {
        return [
            "create",
            "context", "cloudemo",
            "--provider", "default",
            "--registry", "symphonydemo",
            "--api-url",
            this.settings.fnSettings.apiUrl
        ];
    }
    async fnPreRemote(fnFileName) {
        log_1.Logger.log({ message: "Docker command executing. Docker url", timeFormat: "datetime" });
        await shellHelper_1.ShellHelper.ExecuteCommand("docker", this.getDockerCommandArgs());
        //await ShellHelper.ExecuteCommand("docker", ["login", "--username", "symphonydemo", "--password", "f40ddfd4-aad6-4a6a-b3a9-fb54847fb60a"]);
        let continueOnExitCode = 0;
        // await ShellHelper.ExecuteCommand("fn", ["create", "context", "cloudemo", "--provider", "default", "--registry", "symphonydemo", "--api-url", "http://10.223.2.98:90"], {
        log_1.Logger.log({ message: "Fn command executing", timeFormat: "datetime" });
        await shellHelper_1.ShellHelper.ExecuteCommand(fnFileName, this.getFnCommandArgs(), {
            stderr: (chunk) => {
                if (chunk.indexOf("Fn: Context already exists") > -1) {
                    log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", chunk), timeFormat: "datetime" });
                    continueOnExitCode = 1;
                    log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "we got it, context exits"), timeFormat: "datetime" });
                    return false;
                }
                return true;
            },
            exit: (code) => {
                if (!code || !continueOnExitCode) {
                    return null;
                }
                return { code: null, signal: null };
            }
        });
        if (continueOnExitCode == 1) {
            await this.fnContext("default", fnFileName);
            await this.fnContextDelete("cloudemo", fnFileName);
            await this.fnPreRemote(fnFileName);
            return;
        }
        log_1.Logger.log({ message: "fnContext step running...", timeFormat: "datetime" });
        await this.fnContext("cloudemo", fnFileName);
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Pre Fn complete"), timeFormat: "datetime" });
    }
    async fnContextDelete(contextName, fnFileName) {
        log_1.Logger.log({ message: "fnContext delete existing context...: " + contextName, timeFormat: "datetime" });
        await shellHelper_1.ShellHelper.ExecuteCommand(fnFileName, ["delete", "context", contextName]);
        log_1.Logger.log({ message: "fnContext deleted existing context: " + contextName, timeFormat: "datetime" });
    }
    async fnContext(contextName, fnFileName) {
        let continueOnExitCode = false;
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "context switching to...: " + contextName), timeFormat: "datetime" });
        await shellHelper_1.ShellHelper.ExecuteCommand(fnFileName, ["use", "context", contextName], {
            stderr: (chunk) => {
                if (chunk.indexOf(`Fn: Context ${contextName} currently in use`) > -1) {
                    log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", chunk), timeFormat: "datetime" });
                    continueOnExitCode = true;
                    log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "we got it context in place"), timeFormat: "datetime" });
                    return false;
                }
                if (chunk.indexOf("error replacing file with tempfile") > -1) {
                    log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", chunk), timeFormat: "datetime" });
                    const homePath = process.env.HOME || process.env.HOMEPATH;
                    log_1.Logger.log({ message: `trying to fix fn. Home path: ${homePath}`, timeFormat: "datetime" });
                    const fnPath = path.join(homePath, '/.fn/');
                    const yamls = fs.readdirSync(fnPath).filter(item => item.startsWith("config.yaml") && item != "config.yaml").map(item => { const file = path.join(fnPath, item); return { file, ctime: fs.statSync(file) }; });
                    log_1.Logger.log({ message: yamls.map(yaml => yaml.file).join(","), timeFormat: "datetime" });
                    if (yamls.length < 1) {
                        return false;
                    }
                    const latestYaml = yamls.reduce((prev, cur, index) => cur.ctime > prev.ctime ? cur : prev, yamls[0]);
                    log_1.Logger.log({ message: "using yaml: " + latestYaml.file, timeFormat: "datetime" });
                    fs.unlinkSync(path.join(fnPath, "config.yaml"));
                    fs.renameSync(latestYaml.file, path.join(fnPath, "config.yaml"));
                    yamls.filter(yaml => yaml != latestYaml).forEach(yaml => fs.unlinkSync(yaml.file));
                    continueOnExitCode = true;
                    log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "symphony fixed fn context"), timeFormat: "datetime" });
                    return false;
                }
                return true;
            },
            exit: () => continueOnExitCode ? { code: null, signal: null } : null
        });
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "context switched to: " + contextName), timeFormat: "datetime" });
    }
    async fnDeploy(fnFileName) {
        const args = ["--verbose", "deploy", "--create-app", "--all"];
        if (this.settings.environment === "local") {
            args.push("--local");
        }
        let finalYamlErrorThatShouldBeDiscarded = false;
        let successFunctionCounter = 0;
        await shellHelper_1.ShellHelper.ExecuteCommand(fnFileName, args, {
            stdout: (chunkString) => {
                if (chunkString.indexOf("Updating function") > -1) {
                    log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", chunkString), timeFormat: "datetime" });
                    successFunctionCounter++;
                }
                else if (chunkString.indexOf("Step ") > -1) {
                    log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", chunkString), timeFormat: "datetime" });
                }
                return true;
            },
            stderr: (chunkstring) => {
                if (chunkstring.indexOf("connection attempt failed because the connected party did not properly respond") > -1) {
                    log_1.Logger.log({ message: chalk_1.Chalk.create("yellow.bold", "Connection Issue, did you check VPN ?"), timeFormat: "datetime" });
                }
                if (successFunctionCounter > 0 && chunkstring.indexOf("Fn: yaml: unmarshal errors:") > -1 && chunkstring.indexOf("cannot unmarshal !!map into string") > -1) {
                    log_1.Logger.log({ message: "Skipping final yaml error that should be discarded", timeFormat: "datetime" });
                    finalYamlErrorThatShouldBeDiscarded = true;
                }
                return true;
            },
            exit: (code, signal) => {
                if (finalYamlErrorThatShouldBeDiscarded) {
                    return { code: null, signal: null };
                }
                return null;
            }
        });
    }
}
exports.FnDeployHelper = FnDeployHelper;
