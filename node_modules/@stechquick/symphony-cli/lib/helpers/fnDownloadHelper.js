"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnDownloadHelepr = void 0;
const tslib_1 = require("tslib");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("./chalk");
const fs = tslib_1.__importStar(require("fs"));
const https = tslib_1.__importStar(require("https"));
const shellHelper_1 = require("./shellHelper");
class FnDownloadHelepr {
    constructor(platform) {
        this.downloadPathUrl = "https://github.com/fnproject/cli/releases/download/0.5.99/";
        this.platformFnFileLookup = {
            "win32": "fn.exe",
            "linux": "fn_linux"
        };
        this.platform = platform || process.platform;
        this.fnFileName = this.platformFnFileLookup[this.platform];
    }
    async downloadFn() {
        const fileName = `./${this.fnFileName}`;
        if (fs.existsSync(fileName)) {
            log_1.Logger.log({ message: "Fn file is found. Not download", timeFormat: "datetime" });
            return fileName;
        }
        await this.downloadFnInternal();
        log_1.Logger.log({ message: `Running: chmod +x fileName`, timeFormat: "datetime" });
        await shellHelper_1.ShellHelper.ExecuteCommand("chmod", ["+x", fileName]);
        return fileName;
    }
    async downloadFnInternal() {
        const fileName = `./${this.fnFileName}`;
        log_1.Logger.log({ message: `downloading ${this.fnFileName} from fn project` });
        const url = this.downloadPathUrl + this.fnFileName;
        log_1.Logger.log({ message: "Fn is downloanding from: " + url, timeFormat: "datetime" });
        return new Promise((res, rej) => {
            const request = https.get(url, function (response) {
                if (response.statusCode != 302 || !response.headers.location) {
                    rej({ message: "could not download fn, got http: " + response.statusCode + " " + response.statusMessage });
                    return;
                }
                const requestFnFile = https.get(response.headers.location, response => {
                    if (response.statusCode != 200) {
                        rej({ message: "could not download fn, got http: " + response.statusCode + " " + response.statusMessage });
                    }
                    const length = response.headers["content-length"];
                    log_1.Logger.log({ message: chalk_1.Chalk.create("bold", "downloading length: " + length), timeFormat: "datetime" });
                    const file = fs.createWriteStream(fileName);
                    response.pipe(file);
                    file.on('finish', function () {
                        log_1.Logger.log({ message: "Got it", timeFormat: "datetime" });
                        file.close();
                        setTimeout(res, 1000); // I don't know if file closed, just wait;
                    });
                    log_1.Logger.log({ message: "Got response, writing file", timeFormat: "datetime" });
                }).on('error', function (err) {
                    fs.unlinkSync(fileName); // Delete the file async. (But we don't check the result)
                    rej(err);
                });
            });
        });
    }
}
exports.FnDownloadHelepr = FnDownloadHelepr;
