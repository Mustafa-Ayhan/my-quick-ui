"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmHelper = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const fileHelper_1 = require("@stechquick/symphony-common/lib/helpers/fileHelper");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const initHelper_1 = require("./initHelper");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("./chalk");
class NpmHelper {
    static packageInstall(packageName) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", packageName + " package install starting...") });
        child_process_1.execSync(`npm install ${packageName}`, { stdio: 'inherit' });
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", packageName + " package install finished...") });
    }
    static findPackagePath(packageName) {
        let packageTarget = undefined;
        for (let i = 0, target = "./node_modules/" + packageName; i < 10; i++, target = "../" + target) {
            if (fs.existsSync(target)) {
                packageTarget = target;
                break;
            }
        }
        return packageTarget;
    }
    static install(settings) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Install starting, please wait...") });
        child_process_1.execSync(`cd ${settings.folderName} && npm install`, { stdio: 'inherit' });
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Install finished successfully.") });
    }
    static build(settings) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Build starting, please wait...") });
        this.execCommand(this.BUILD_CMD, settings);
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Build finished successfully.") });
    }
    static buildWebpack(settings) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Webpack starting, please wait...") });
        this.execCommand(this.WEBPACK_CMD, settings);
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Webpack finished successfully.") });
    }
    static extractDistAndLocalJsPath(local_js_dist_path) {
        let localPath = './dist/local';
        let distPath = "./dist/";
        if (!local_js_dist_path) {
            return { localPath, distPath };
        }
        if (local_js_dist_path.endsWith("/local.js") || local_js_dist_path.endsWith("/local")) {
            localPath = local_js_dist_path;
            distPath = localPath.substring(0, localPath.length - (local_js_dist_path.endsWith("/local") ? "/local" : "/local.js").length);
        }
        else {
            distPath = local_js_dist_path;
            localPath = path.join(local_js_dist_path, "/local.js");
        }
        return { localPath, distPath };
    }
    static run(environment, settings) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Function starting, please wait..."), timeFormat: "datetime" });
        if (!initHelper_1.InitHelper.AssertInFolder()) {
            return;
        }
        if (settings.build) {
            this.build();
        }
        const { localPath, distPath } = NpmHelper.extractDistAndLocalJsPath(settings.local_js_dist_path);
        const args = [path.resolve(localPath)];
        if (settings.debug) {
            args.unshift('--inspect-brk');
        }
        const customArgs = {
            httpPort: settings.httpPort,
            httpsPort: settings.httpsPort,
            hostedPath: settings.hostedPath,
            distPath,
        };
        args.push(JSON.stringify(customArgs));
        log_1.Logger.log({ message: "spawning with: ", additional: args });
        const envObject = { NODE_ENV: environment };
        const calcObject = Object.keys(envObject).reduce((prev, key) => { if (envObject[key] !== undefined) {
            prev[key] = envObject[key];
        } return prev; }, {});
        child_process_1.spawnSync("node", args, { env: Object.assign(process.env, calcObject), stdio: 'inherit' });
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Function started successfully."), timeFormat: "datetime" });
    }
    static getCurrentPackageVersions() {
        const list = child_process_1.execSync("npm list --depth=0 -json", { encoding: "utf8" });
        if (!list || list.length == 0) {
            return {};
        }
        ;
        const lines = list.split("\n");
        if (lines[0].indexOf("npm is compatible with") > -1) {
            throw lines[0];
        }
        let started, ended;
        const jsonValue = lines.filter(line => {
            if (line.startsWith("{")) {
                started = true;
            }
            if (line.startsWith("}")) {
                ended = true;
                return true;
            }
            return started && !ended;
        }).join("");
        const json = JSON.parse(jsonValue);
        if (!json.dependencies) {
            return {};
        }
        const retVal = Object.keys(json.dependencies).reduce((prev, cur) => { prev[`${cur}`] = json.dependencies[cur].version; return prev; }, {});
        return retVal;
    }
    static execCommand(command, settings) {
        fileHelper_1.FileHelper.removeDist();
        //https://github.com/npm/npx 
        //npx added instead of "./node_modules/.bin/"
        //const cwd = "./node_modules/.bin/";
        const stdio = "inherit";
        if (settings === null || settings === void 0 ? void 0 : settings.watch) {
            command = command + " -w";
        }
        child_process_1.execSync(command, { stdio });
    }
}
exports.NpmHelper = NpmHelper;
NpmHelper.BUILD_CMD = "npx tsc";
NpmHelper.WEBPACK_CMD = "npx webpack";
