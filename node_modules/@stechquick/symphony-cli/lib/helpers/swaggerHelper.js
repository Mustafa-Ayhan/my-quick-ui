"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerHelper = void 0;
const tslib_1 = require("tslib");
const fsExtra = require("fs-extra");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const npmHelper_1 = require("../helpers/npmHelper");
const symtypeconv_1 = require("../../symtypeconv/dist/symtypeconv");
let SwaggerDict = {
    symSwaggerFolderPath: "./sym-engine/swagger",
    symSwaggerJsonPath: "./sym-engine/swagger/swagger.json",
    distSwaggerFolderPath: "./sym-engine/swagger",
    distSwaggerUIdistPath: "./sym-engine/swagger/swagger-ui-dist",
    swaggerPackageName: "swagger-ui-dist"
};
class SwaggerHelper {
    appendtoTemplatePaths(fileName, obj) {
        obj.paths[`/${fileName}`] = {
            "get": {
                "tags": [],
                "summary": "",
                "description": "",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IRequest`,
                                },
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IResponse`
                                },
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IRequestHeader`
                                },
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IResponseHeader`
                                }
                            ]
                        }
                    }
                }
            },
            "post": {
                "tags": [],
                "summary": "",
                "description": "",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "successful operation",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IRequest`,
                                },
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IResponse`
                                },
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IRequestHeader`
                                },
                                {
                                    "$ref": `swaggerAPI/${fileName}Schema.json#/definitions/IResponseHeader`
                                }
                            ]
                        }
                    }
                }
            }
        };
    }
    async generateSwaggerJSON(dirPath) {
        let files = fs_1.default.readdirSync(dirPath);
        if (!files)
            return;
        if (!fs_1.default.existsSync(SwaggerDict.symSwaggerFolderPath))
            fs_1.default.mkdir(SwaggerDict.symSwaggerFolderPath, (err) => { if (err)
                throw err; });
        let swaggerJson;
        files.forEach(async (file) => {
            if (fs_1.default.statSync(dirPath + "/" + file).isDirectory()) {
                await this.generateSwaggerJSON(dirPath + "/" + file);
            }
            if (file.endsWith(".ts")) {
                var fileName = file.replace(".ts", "");
                if (!fs_1.default.existsSync(SwaggerDict.symSwaggerJsonPath)) {
                    this.appendtoTemplatePaths(fileName, SwaggerHelper.swaggerTemplate);
                }
                var fileData = fs_1.default.readFileSync(dirPath + "/" + file, 'utf8');
                if (!fileData || fileData.length == 0)
                    return;
                var data = await symtypeconv_1.SymTypeConv.generateJsonSchema(fileName, fileData);
                fs_1.default.writeFileSync('./sym-engine/swagger/' + fileName + 'Schema.json', data);
            }
        });
        if (fs_1.default.existsSync('./app.yaml') && !fs_1.default.existsSync(SwaggerDict.symSwaggerJsonPath)) {
            let fileContent = fs_1.default.readFileSync('./app.yaml', 'utf8');
            let appName = fileContent.substring(fileContent.indexOf(':') + 2);
            SwaggerHelper.swaggerTemplate["info"].title = appName;
            SwaggerHelper.swaggerTemplate["basePath"] = "/" + appName;
            swaggerJson = SwaggerHelper.swaggerTemplate;
        }
        return swaggerJson;
    }
    async Swagger(jsonPath, local_js_dist_path) {
        let swaggerTemplate = await this.generateSwaggerJSON(jsonPath);
        // if swagger.json has been created before, generateSwaggerJSON returns null to prevent overwriting modifications in swagger.json file
        if (!swaggerTemplate) {
            let functions = fs_1.default.readdirSync(jsonPath);
            SwaggerHelper.existedSwaggerJson = JSON.parse(fs_1.default.readFileSync(SwaggerDict.symSwaggerJsonPath, 'utf8'));
            functions.forEach(func => {
                let currFile = func;
                let notIncluded = true;
                Object.keys(SwaggerHelper.existedSwaggerJson.paths).forEach(key => {
                    let flag = false;
                    if (key.includes(currFile)) {
                        notIncluded = false;
                        flag = true;
                    }
                    if (flag)
                        return;
                });
                if (notIncluded) {
                    this.appendtoTemplatePaths(func, SwaggerHelper.existedSwaggerJson);
                }
            });
            Object.keys(SwaggerHelper.existedSwaggerJson.paths).forEach(key => {
                let currKey = key;
                let notIncluded = true;
                functions.forEach(file => {
                    let flag = false;
                    if (currKey.includes(file)) {
                        notIncluded = false;
                        flag = true;
                    }
                    if (flag)
                        return;
                });
                if (notIncluded) {
                    delete SwaggerHelper.existedSwaggerJson.paths[key];
                    let schemas = fs_1.default.readdirSync(SwaggerDict.symSwaggerFolderPath);
                    schemas.forEach(schema => {
                        if (schema !== "swagger.json")
                            schema = schema.replace("Schema.json", "");
                        if (schema !== "swagger.json" && key.includes(schema)) {
                            fs_1.default.unlinkSync(SwaggerDict.symSwaggerFolderPath + "/" + schema + 'Schema.json');
                        }
                    });
                }
            });
            fs_1.default.writeFileSync(SwaggerDict.symSwaggerJsonPath, JSON.stringify(SwaggerHelper.existedSwaggerJson));
        }
        else {
            fs_1.default.writeFileSync(SwaggerDict.symSwaggerJsonPath, JSON.stringify(swaggerTemplate));
        }
        const { distPath } = npmHelper_1.NpmHelper.extractDistAndLocalJsPath(local_js_dist_path);
        const distSwaggerFolderPath = path_1.default.join(distPath, SwaggerDict.distSwaggerFolderPath);
        const distSwaggerUIdistPath = path_1.default.join(distPath, SwaggerDict.distSwaggerUIdistPath);
        await fsExtra.copy(SwaggerDict.symSwaggerFolderPath, distSwaggerFolderPath);
        let swaggerPackagePath = npmHelper_1.NpmHelper.findPackagePath(SwaggerDict.swaggerPackageName);
        if (swaggerPackagePath) {
            fsExtra.copySync(swaggerPackagePath, distSwaggerUIdistPath);
            return;
        }
        npmHelper_1.NpmHelper.packageInstall(SwaggerDict.swaggerPackageName);
        swaggerPackagePath = npmHelper_1.NpmHelper.findPackagePath(SwaggerDict.swaggerPackageName);
        if (!swaggerPackagePath) {
            throw new Error(`node package ${SwaggerDict.swaggerPackageName} could not be located on any node_modules`);
        }
        fsExtra.copySync(swaggerPackagePath, distSwaggerUIdistPath);
    }
    async SwaggerSchemaInclusive(local_js_dist_path) {
        debugger;
        let swaggerJson = SwaggerHelper.existedSwaggerJson || SwaggerHelper.swaggerTemplate;
        let schemas = fs_1.default.readdirSync(SwaggerDict.symSwaggerFolderPath);
        const { distPath } = npmHelper_1.NpmHelper.extractDistAndLocalJsPath(local_js_dist_path);
        const distSwaggerFolderPath = path_1.default.join(distPath, SwaggerDict.distSwaggerFolderPath);
        schemas.forEach(schema => {
            if (schema === "swagger.json")
                return;
            let schemaObj = JSON.parse(fs_1.default.readFileSync(SwaggerDict.symSwaggerFolderPath + "/" + schema, 'utf8'));
            schema = schema.replace("Schema.json", "");
            Object.keys(swaggerJson.paths).forEach(key => {
                if (key.includes(schema)) {
                    let schemaArrayGet = swaggerJson.paths[key].get.responses["200"].schema.allOf = [];
                    let schemaArrayPost = swaggerJson.paths[key].post.responses["200"].schema.allOf = [];
                    Object.keys(schemaObj.definitions).forEach(currentInterface => {
                        schemaArrayGet.push(schemaObj.definitions[currentInterface]);
                        schemaArrayPost.push(schemaObj.definitions[currentInterface]);
                    });
                }
            });
        });
        fs_1.default.writeFileSync(SwaggerDict.symSwaggerFolderPath + "/swaggerSchemaInclusive.json", JSON.stringify(swaggerJson));
        fsExtra.copy(SwaggerDict.symSwaggerFolderPath, distSwaggerFolderPath);
    }
}
exports.SwaggerHelper = SwaggerHelper;
SwaggerHelper.swaggerTemplate = {
    "swagger": "2.0",
    "info": {
        "description": "You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.",
        "version": "1.0.6",
        "title": ""
    },
    "basePath": "",
    "produces": [
        "application/json",
        "application/xml"
    ],
    "schemes": ["http", "https"],
    "securityDefinitions": {
        "JWT": {
            "type": "apiKey",
            "in": "header",
            "name": "Authorization",
            "description": "Basic apiKey Authotization in the system"
        }
    },
    "paths": {}
};
