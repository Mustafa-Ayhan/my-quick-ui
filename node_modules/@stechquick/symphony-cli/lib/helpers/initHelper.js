"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitHelper = exports.CommandType = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const fileHelper_1 = require("@stechquick/symphony-common/lib/helpers/fileHelper");
const log_1 = require("@stechquick/symphony-common/lib/log");
const chalk_1 = require("./chalk");
var CommandType;
(function (CommandType) {
    CommandType[CommandType["createapp"] = 1] = "createapp";
    CommandType[CommandType["addfunc"] = 2] = "addfunc";
})(CommandType = exports.CommandType || (exports.CommandType = {}));
class InitHelper {
    constructor() {
        this.subPath = "./";
        this.replaceMap = new Map();
        this.funcNameRegExp = /{{FuncName}}/g;
        this.appNameRegExp = /{{AppName}}/g;
        this.moduleNameRegExp = /{{ModuleName}}/g;
        this.removeRegExp = /{{remove}}/g;
        this.appDescRegExp = /{{AppDesc}}/g;
        this.npmrcTokenRegExp = /{{NpmrcStechQuickToken}}/g;
        this.moduleDescRegExp = /{{ModuleDesc}}/g;
        this.addFuncSearchPath = "/templates/addfunc";
        this.initSearchPath = "/templates/init";
        this.moduleSearchPath = "/templates/addModule";
        this.replaceMap.set(this.removeRegExp, "");
    }
    static AssertInFolder() {
        let retVal = fs.existsSync("./functions") && fs.existsSync("./package.json") && fs.existsSync("./local.ts");
        if (!retVal) {
            log_1.Logger.log({ message: chalk_1.Chalk.create("red.bold", "Command must be executed in app root!"), timeFormat: "datetime" });
        }
        return retVal;
    }
    async AddFunc(funcName) {
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Function " + funcName + " adding. Please wait..."), timeFormat: "datetime" });
        this.replaceMap.set(this.funcNameRegExp, funcName);
        if (!InitHelper.AssertInFolder()) {
            return;
        }
        if (fs.existsSync("./functions/" + funcName)) {
            const answer = await cli_ux_1.default.confirm("Function: " + funcName + " already exists. If you have any, you will lose your pending changes. Would you like to overwrite it? [Y/N]");
            if (!answer) {
                return;
            }
        }
        const addFuncTemplatePath = path.join(path.resolve(__dirname), "../.." + this.addFuncSearchPath);
        fileHelper_1.FileHelper.exportFiles({ sourcePath: addFuncTemplatePath, targetPath: "./", replaceMap: this.replaceMap });
        log_1.Logger.log({ message: chalk_1.Chalk.create("green.bold", "Function " + funcName + " added successfully."), timeFormat: "datetime" });
    }
    async AddApp(appName, appDesc, npmToken, registry) {
        if (npmToken == "" && registry == "") {
            log_1.Logger.log({ message: chalk_1.Chalk.create("yellow.bold", "ERR! token or registry required. Let's follow the documentation step by step: https://docs.onplateau.com/Symphony/create-symphony"), timeFormat: "datetime" });
            return false;
        }
        this.replaceMap.set(this.appNameRegExp, appName);
        this.replaceMap.set(this.appDescRegExp, appDesc);
        let tokenInfo = "";
        if (npmToken) {
            tokenInfo = "@stechquick:registry=https://registry.npmjs.org/" + "\r\n" + "//registry.npmjs.org/:_authToken=" + npmToken;
        }
        else if (registry) {
            //https://scorenexus.isbank/repository/npm-stechquick-registry-proxy-repo/
            tokenInfo = "registry=" + registry + "\r\n" + "strict-ssl=false";
        }
        this.replaceMap.set(this.npmrcTokenRegExp, tokenInfo);
        const existsSubPath = fs.existsSync(this.subPath + appName);
        if (existsSubPath) {
            const answer = await cli_ux_1.default.confirm("App: " + appName + " already exists. If you have any, you will lose your pending changes. Would you like to overwrite it?");
            if (!answer) {
                return false;
            }
        }
        const templatePath = path.join(path.resolve(__dirname), "../.." + this.initSearchPath);
        fileHelper_1.FileHelper.exportFiles({ sourcePath: templatePath, targetPath: "./", replaceMap: this.replaceMap });
    }
    async AddModule(moduleName, moduleDesc) {
        this.replaceMap.set(this.moduleNameRegExp, moduleName);
        this.replaceMap.set(this.moduleDescRegExp, moduleDesc);
        const existsSubPath = fs.existsSync(this.subPath + moduleName);
        if (existsSubPath) {
            const answer = await cli_ux_1.default.confirm("Module: " + moduleName + " already exists. If you have any, you will lose your pending changes. Would you like to overwrite it?");
            if (!answer) {
                return;
            }
        }
        const templatePath = path.join(path.resolve(__dirname), "../.." + this.moduleSearchPath);
        fileHelper_1.FileHelper.exportFiles({ sourcePath: templatePath, targetPath: "./", replaceMap: this.replaceMap });
    }
}
exports.InitHelper = InitHelper;
